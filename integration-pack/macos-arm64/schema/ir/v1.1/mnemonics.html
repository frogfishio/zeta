<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ZASM Assembly Language Specification</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap');
    :root {
      --bg: #0f1828;
      --card: rgba(255, 255, 255, 0.08);
      --text: #f4f7ff;
      --muted: #a8b3cf;
      --accent: #f6c343;
      --border: rgba(244, 247, 255, 0.2);
    }
    * { box-sizing: border-box; }
    body { margin: 0; min-height: 100vh; font-family: 'Space Grotesk', 'IBM Plex Sans', sans-serif; background: radial-gradient(circle at top left, #1f3158, #0b1321 70%); color: var(--text); padding: 3rem 1.5rem; }
    h1 { font-size: 2.25rem; margin-bottom: 0.5rem; }
    h2 { font-size: 1.25rem; margin: 1.75rem 0 0.5rem; color: var(--accent); }
    p.lede { max-width: 760px; color: var(--muted); line-height: 1.6; margin-bottom: 2rem; }
    .spec { max-width: 900px; background: rgba(15, 24, 40, 0.45); border: 1px solid var(--border); border-radius: 1rem; padding: 1.5rem 1.6rem; margin-bottom: 2rem; }
    .spec p { margin: 0.5rem 0 0.75rem; color: var(--text); line-height: 1.6; }
    .spec ul { margin: 0.5rem 0 0.75rem 1.2rem; padding: 0; color: var(--muted); line-height: 1.6; }
    .spec code { font-family: 'JetBrains Mono', 'Fira Code', monospace; font-size: 0.9em; color: var(--text); }
    table { width: 100%; border-collapse: collapse; background: var(--card); border: 1px solid var(--border); border-radius: 1rem; overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.35); }
    thead { background: rgba(15, 24, 40, 0.65); backdrop-filter: blur(6px); }
    th, td { text-align: left; padding: 0.9rem 1rem; border-bottom: 1px solid var(--border); vertical-align: top; }
    th { font-weight: 600; color: var(--accent); letter-spacing: 0.05em; font-size: 0.9rem; text-transform: uppercase; }
    tbody tr:nth-child(odd) { background: rgba(255, 255, 255, 0.02); }
    tbody tr:hover { background: rgba(246, 195, 67, 0.07); }
    td:nth-child(1) { font-weight: 600; }
    pre { margin: 0; font-family: 'JetBrains Mono', 'Fira Code', monospace; font-size: 0.78rem; line-height: 1.4; white-space: pre-wrap; word-break: break-all; color: #fefefe; }
    @media (max-width: 960px) {
      table, thead, tbody, th, td, tr { display: block; }
      thead { display: none; }
      tbody tr { padding: 1rem; border-bottom: 1px solid var(--border); }
      td { border: none; padding: 0.65rem 0; }
      td::before { content: attr(data-label); display: block; color: var(--muted); text-transform: uppercase; font-size: 0.75rem; letter-spacing: 0.05em; margin-bottom: 0.25rem; }
    }
  </style>
</head>
<body>
  <h1>ZASM Assembly Language Specification</h1>
  <p class="lede">Normative specification of ZASM v1.0 mnemonics, directives, operand shapes, and JSONL emission. This document is prescriptive: programs are valid only if they conform to the rules below and the table that follows.</p>
  <section class="spec">
    <h2>Status and scope</h2>
    <p>This document defines the complete, authoritative ZASM assembly language vocabulary. Any mnemonic or directive not listed in the table is invalid and MUST be rejected. When this document conflicts with any other source, this document is the standard.</p>
    <p>The operand shape column is normative (the word "suggested" is legacy). Each instruction or directive line MUST match one of the listed shapes exactly.</p>
    <p>The WASM equivalent column is informative only. Semantics are defined by the operand shape and the "What it does" description.</p>

    <h2>Lexical forms</h2>
    <ul>
      <li>Identifiers (<code>ID</code>) start with <code>A-Z</code>, <code>a-z</code>, <code>_</code>, <code>.</code>, or <code>$</code>, and then contain <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, <code>_</code>, <code>.</code>, or <code>$</code>.</li>
      <li>Numbers (<code>NUM</code>) are non-negative decimal or hexadecimal (<code>0x</code> prefix) integers.</li>
      <li>Strings (<code>STR</code>) are double-quoted. A backslash escapes the following character. The sequence <code>\\</code> produces a single backslash.</li>
      <li>Comments begin with <code>;</code> and run to the end of the line.</li>
      <li>Mnemonics and directives are case-sensitive and MUST be uppercase.</li>
    </ul>

    <h2>Statements, labels, and operands</h2>
    <ul>
      <li>A statement is either an instruction or a directive. Each line contains at most one statement.</li>
      <li>A label is an <code>ID</code> followed by <code>:</code>. A label may appear alone on a line or before a statement on the same line.</li>
      <li>For two-operand instructions, the first operand is the destination unless the description explicitly states otherwise.</li>
      <li><code>r</code> denotes a register identifier. Implementations MUST reject unknown register names.</li>
      <li><code>x</code> denotes either a register identifier, a numeric literal, or a symbol (<code>ID</code>).</li>
      <li><code>(addr)</code> denotes a memory operand. The operand inside parentheses MUST be a single <code>ID</code> naming the base address symbol.</li>
      <li><code>target</code> denotes a single <code>ID</code> label.</li>
    </ul>

    <h2>Control flow conditions</h2>
    <p><code>JR</code> has two legal forms: <code>JR target</code> or <code>JR cond, target</code>. The condition MUST be one of <code>EQ</code>, <code>NE</code>, <code>LT</code>, <code>LE</code>, <code>GT</code>, or <code>GE</code>, and it is evaluated against the comparison register produced by <code>CP</code>.</p>

    <h2>JSONL emission (normative)</h2>
    <ul>
      <li>Each instruction line emits exactly one <code>instr</code> record: <code>{"ir":"zasm-v1.0","k":"instr","m":"MNEMONIC","ops":[...],"loc":{"line":N}}</code>.</li>
      <li>Each directive line emits exactly one <code>dir</code> record: <code>{"ir":"zasm-v1.0","k":"dir","d":"DIRECTIVE","args":[...],"loc":{"line":N}}</code>. If a label prefixes a directive, the record also includes <code>"name":"LABEL"</code>.</li>
      <li>Operand encoding is fixed: register or symbol <code>ID</code> is <code>{"t":"sym","v":"ID"}</code>; number is <code>{"t":"num","v":123}</code>; string is <code>{"t":"str","v":"TEXT"}</code>; memory operand is <code>{"t":"mem","base":"ID"}</code>.</li>
      <li><code>loc.line</code> is a 1-based source line number for the statement.</li>
    </ul>
  </section>
  <table>
    <thead>
      <tr>
        <th>ZASM mnemonic</th>
        <th>ZASM opcode (hex)</th>
        <th>Operand shape (suggested)</th>
        <th>WASM equivalent</th>
        <th>RV64I equivalent</th>
        <th>What it does</th>
        <th>JSONL</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td data-label="ZASM mnemonic">ADD</td>
        <td data-label="ZASM opcode (hex)">0x10</td>
        <td data-label="Operand shape (suggested)">ADD HL, x</td>
        <td data-label="WASM equivalent">i32.add</td>
        <td data-label="RV64I equivalent">addw + zext.w</td>
        <td data-label="What it does">Add immediates or DE into HL.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ADD&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;}],&quot;loc&quot;:{&quot;line&quot;:9}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">ADD64</td>
        <td data-label="ZASM opcode (hex)">0x20</td>
        <td data-label="Operand shape (suggested)">ADD64 HL, x</td>
        <td data-label="WASM equivalent">i64.add</td>
        <td data-label="RV64I equivalent">add</td>
        <td data-label="What it does">Add 64-bit immediates or DE into HL.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ADD64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;}],&quot;loc&quot;:{&quot;line&quot;:3}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">AND</td>
        <td data-label="ZASM opcode (hex)">0x17</td>
        <td data-label="Operand shape (suggested)">AND HL, x</td>
        <td data-label="WASM equivalent">i32.and</td>
        <td data-label="RV64I equivalent">and</td>
        <td data-label="What it does">Bitwise AND register with scalar/symbol.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;AND&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:255}],&quot;loc&quot;:{&quot;line&quot;:11}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">AND64</td>
        <td data-label="ZASM opcode (hex)">0x27</td>
        <td data-label="Operand shape (suggested)">AND64 HL, x</td>
        <td data-label="WASM equivalent">i64.and</td>
        <td data-label="RV64I equivalent">and</td>
        <td data-label="What it does">Bitwise AND a 64-bit register with scalar/symbol data.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;AND64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;}],&quot;loc&quot;:{&quot;line&quot;:12}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">CALL</td>
        <td data-label="ZASM opcode (hex)">0x00</td>
        <td data-label="Operand shape (suggested)">CALL target</td>
        <td data-label="WASM equivalent">call target / host stub</td>
        <td data-label="RV64I equivalent">jal/jalr</td>
        <td data-label="What it does">Invoke a user function or Lembeh primitive.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;CALL&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;_out&quot;}],&quot;loc&quot;:{&quot;line&quot;:12}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">CLZ</td>
        <td data-label="ZASM opcode (hex)">0x35</td>
        <td data-label="Operand shape (suggested)">CLZ r</td>
        <td data-label="WASM equivalent">i32.clz</td>
        <td data-label="RV64I equivalent">clzw (Zbb) + zext.w</td>
        <td data-label="What it does">Count leading zeros of a register.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;CLZ&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;}],&quot;loc&quot;:{&quot;line&quot;:33}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">CLZ64</td>
        <td data-label="ZASM opcode (hex)">0x45</td>
        <td data-label="Operand shape (suggested)">CLZ64 r</td>
        <td data-label="WASM equivalent">i64.clz</td>
        <td data-label="RV64I equivalent">clz (Zbb)</td>
        <td data-label="What it does">Count leading zeros of a 64-bit register.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;CLZ64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;}],&quot;loc&quot;:{&quot;line&quot;:38}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">CP</td>
        <td data-label="ZASM opcode (hex)">0x03</td>
        <td data-label="Operand shape (suggested)">CP HL, x</td>
        <td data-label="WASM equivalent">i32.sub -&gt; cmp</td>
        <td data-label="RV64I equivalent">sub (cmp temp)</td>
        <td data-label="What it does">Compute HL - x and write the comparison register used by JR conditions.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;CP&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;}],&quot;loc&quot;:{&quot;line&quot;:7}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">CTZ</td>
        <td data-label="ZASM opcode (hex)">0x36</td>
        <td data-label="Operand shape (suggested)">CTZ r</td>
        <td data-label="WASM equivalent">i32.ctz</td>
        <td data-label="RV64I equivalent">ctzw (Zbb) + zext.w</td>
        <td data-label="What it does">Count trailing zeros of a register.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;CTZ&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;}],&quot;loc&quot;:{&quot;line&quot;:34}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">CTZ64</td>
        <td data-label="ZASM opcode (hex)">0x46</td>
        <td data-label="Operand shape (suggested)">CTZ64 r</td>
        <td data-label="WASM equivalent">i64.ctz</td>
        <td data-label="RV64I equivalent">ctz (Zbb)</td>
        <td data-label="What it does">Count trailing zeros of a 64-bit register.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;CTZ64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;}],&quot;loc&quot;:{&quot;line&quot;:39}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">DB</td>
        <td data-label="ZASM opcode (hex)">—</td>
        <td data-label="Operand shape (suggested)">DB value[, ...]</td>
        <td data-label="WASM equivalent">data bytes</td>
        <td data-label="RV64I equivalent">n/a (directive)</td>
        <td data-label="What it does">Define literal bytes (optionally labeled).</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;dir&quot;,&quot;d&quot;:&quot;DB&quot;,&quot;args&quot;:[{&quot;t&quot;:&quot;str&quot;,&quot;v&quot;:&quot;Hello&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:10},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:0}],&quot;loc&quot;:{&quot;line&quot;:5},&quot;name&quot;:&quot;msg&quot;}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">DEC</td>
        <td data-label="ZASM opcode (hex)">0x06</td>
        <td data-label="Operand shape (suggested)">DEC r (DE|BC)</td>
        <td data-label="WASM equivalent">i32.sub</td>
        <td data-label="RV64I equivalent">addi/addiw -1</td>
        <td data-label="What it does">Decrement DE or BC by one.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;DEC&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;}],&quot;loc&quot;:{&quot;line&quot;:18}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">DIVS</td>
        <td data-label="ZASM opcode (hex)">0x13</td>
        <td data-label="Operand shape (suggested)">DIVS HL, x</td>
        <td data-label="WASM equivalent">i32.div_s</td>
        <td data-label="RV64I equivalent">divw + zext.w (trap on div0) (trap on div0)</td>
        <td data-label="What it does">Signed division (traps like WASM).</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;DIVS&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:3}],&quot;loc&quot;:{&quot;line&quot;:19}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">DIVS64</td>
        <td data-label="ZASM opcode (hex)">0x23</td>
        <td data-label="Operand shape (suggested)">DIVS64 HL, x</td>
        <td data-label="WASM equivalent">i64.div_s</td>
        <td data-label="RV64I equivalent">div (trap on div0)</td>
        <td data-label="What it does">Signed 64-bit division (same traps as WASM).</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;DIVS64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:3}],&quot;loc&quot;:{&quot;line&quot;:6}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">DIVU</td>
        <td data-label="ZASM opcode (hex)">0x14</td>
        <td data-label="Operand shape (suggested)">DIVU HL, x</td>
        <td data-label="WASM equivalent">i32.div_u</td>
        <td data-label="RV64I equivalent">divuw + zext.w (trap on div0) (trap on div0)</td>
        <td data-label="What it does">Unsigned division (traps on div0).</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;DIVU&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:2}],&quot;loc&quot;:{&quot;line&quot;:20}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">DIVU64</td>
        <td data-label="ZASM opcode (hex)">0x24</td>
        <td data-label="Operand shape (suggested)">DIVU64 HL, x</td>
        <td data-label="WASM equivalent">i64.div_u</td>
        <td data-label="RV64I equivalent">divu (trap on div0)</td>
        <td data-label="What it does">Unsigned 64-bit division (traps on div0).</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;DIVU64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:4}],&quot;loc&quot;:{&quot;line&quot;:7}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">DROP</td>
        <td data-label="ZASM opcode (hex)">0x04 (pseudo)</td>
        <td data-label="Operand shape (suggested)">DROP r</td>
        <td data-label="WASM equivalent">drop</td>
        <td data-label="RV64I equivalent">mv x0, r (pseudo)</td>
        <td data-label="What it does">Explicitly discard a register value.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;DROP&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;IX&quot;}],&quot;loc&quot;:{&quot;line&quot;:47}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">DW</td>
        <td data-label="ZASM opcode (hex)">—</td>
        <td data-label="Operand shape (suggested)">DW value[, ...]</td>
        <td data-label="WASM equivalent">data words</td>
        <td data-label="RV64I equivalent">n/a (directive)</td>
        <td data-label="What it does">Define 32-bit little-endian words.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;dir&quot;,&quot;d&quot;:&quot;DW&quot;,&quot;args&quot;:[{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:1024}],&quot;loc&quot;:{&quot;line&quot;:6},&quot;name&quot;:&quot;msg_len&quot;}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">EQ</td>
        <td data-label="ZASM opcode (hex)">0x50</td>
        <td data-label="Operand shape (suggested)">EQ HL, x</td>
        <td data-label="WASM equivalent">i32.eq</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Compare equals -&gt; 0/1 in destination register.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;EQ&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:2}],&quot;loc&quot;:{&quot;line&quot;:21}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">EQ64</td>
        <td data-label="ZASM opcode (hex)">0x60</td>
        <td data-label="Operand shape (suggested)">EQ64 HL, x</td>
        <td data-label="WASM equivalent">i64.eq</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Compare 64-bit values for equality, returning 0/1.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;EQ64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;}],&quot;loc&quot;:{&quot;line&quot;:26}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">EQU</td>
        <td data-label="ZASM opcode (hex)">—</td>
        <td data-label="Operand shape (suggested)">name: EQU value</td>
        <td data-label="WASM equivalent">const alias</td>
        <td data-label="RV64I equivalent">n/a (directive)</td>
        <td data-label="What it does">Bind a label to a constant expression.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;dir&quot;,&quot;d&quot;:&quot;EQU&quot;,&quot;args&quot;:[{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:16}],&quot;loc&quot;:{&quot;line&quot;:12},&quot;name&quot;:&quot;buf_size&quot;}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">EXTERN</td>
        <td data-label="ZASM opcode (hex)">—</td>
        <td data-label="Operand shape (suggested)">EXTERN module, field, local</td>
        <td data-label="WASM equivalent">import</td>
        <td data-label="RV64I equivalent">n/a (directive)</td>
        <td data-label="What it does">Declare an imported host symbol.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;dir&quot;,&quot;d&quot;:&quot;EXTERN&quot;,&quot;args&quot;:[{&quot;t&quot;:&quot;str&quot;,&quot;v&quot;:&quot;env&quot;},{&quot;t&quot;:&quot;str&quot;,&quot;v&quot;:&quot;noop&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;noop&quot;}],&quot;loc&quot;:{&quot;line&quot;:4}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">FILL</td>
        <td data-label="ZASM opcode (hex)">0x91 (pseudo)</td>
        <td data-label="Operand shape (suggested)">FILL (HL dst, A byte, BC len)</td>
        <td data-label="WASM equivalent">memory.fill</td>
        <td data-label="RV64I equivalent">memset loop (pseudo)</td>
        <td data-label="What it does">Bulk fill memory via Lembeh ABI registers.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;FILL&quot;,&quot;ops&quot;:[],&quot;loc&quot;:{&quot;line&quot;:51}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">GES</td>
        <td data-label="ZASM opcode (hex)">0x55</td>
        <td data-label="Operand shape (suggested)">GES HL, x</td>
        <td data-label="WASM equivalent">i32.ge_s</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Signed &gt;= compare -&gt; 0/1.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;GES&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:2}],&quot;loc&quot;:{&quot;line&quot;:31}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">GES64</td>
        <td data-label="ZASM opcode (hex)">0x65</td>
        <td data-label="Operand shape (suggested)">GES64 HL, x</td>
        <td data-label="WASM equivalent">i64.ge_s</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Signed 64-bit greater-or-equal compare.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;GES64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:5}],&quot;loc&quot;:{&quot;line&quot;:34}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">GEU</td>
        <td data-label="ZASM opcode (hex)">0x59</td>
        <td data-label="Operand shape (suggested)">GEU HL, x</td>
        <td data-label="WASM equivalent">i32.ge_u</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Unsigned &gt;= compare -&gt; 0/1.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;GEU&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:2}],&quot;loc&quot;:{&quot;line&quot;:32}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">GEU64</td>
        <td data-label="ZASM opcode (hex)">0x69</td>
        <td data-label="Operand shape (suggested)">GEU64 HL, x</td>
        <td data-label="WASM equivalent">i64.ge_u</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Unsigned 64-bit greater-or-equal compare.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;GEU64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:6}],&quot;loc&quot;:{&quot;line&quot;:35}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">GTS</td>
        <td data-label="ZASM opcode (hex)">0x54</td>
        <td data-label="Operand shape (suggested)">GTS HL, x</td>
        <td data-label="WASM equivalent">i32.gt_s</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Signed &gt; compare -&gt; 0/1.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;GTS&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:1}],&quot;loc&quot;:{&quot;line&quot;:29}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">GTS64</td>
        <td data-label="ZASM opcode (hex)">0x64</td>
        <td data-label="Operand shape (suggested)">GTS64 HL, x</td>
        <td data-label="WASM equivalent">i64.gt_s</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Signed 64-bit greater-than compare.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;GTS64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:3}],&quot;loc&quot;:{&quot;line&quot;:32}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">GTU</td>
        <td data-label="ZASM opcode (hex)">0x58</td>
        <td data-label="Operand shape (suggested)">GTU HL, x</td>
        <td data-label="WASM equivalent">i32.gt_u</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Unsigned &gt; compare -&gt; 0/1.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;GTU&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:1}],&quot;loc&quot;:{&quot;line&quot;:30}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">GTU64</td>
        <td data-label="ZASM opcode (hex)">0x68</td>
        <td data-label="Operand shape (suggested)">GTU64 HL, x</td>
        <td data-label="WASM equivalent">i64.gt_u</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Unsigned 64-bit greater-than compare.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;GTU64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:4}],&quot;loc&quot;:{&quot;line&quot;:33}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">INC</td>
        <td data-label="ZASM opcode (hex)">0x05</td>
        <td data-label="Operand shape (suggested)">INC r (HL|DE|BC)</td>
        <td data-label="WASM equivalent">i32.add</td>
        <td data-label="RV64I equivalent">addi/addiw +1</td>
        <td data-label="What it does">Increment HL, DE, or BC by one.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;INC&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;}],&quot;loc&quot;:{&quot;line&quot;:17}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">JR</td>
        <td data-label="ZASM opcode (hex)">0x02</td>
        <td data-label="Operand shape (suggested)">JR label | JR cond, label</td>
        <td data-label="WASM equivalent">pc dispatch branch</td>
        <td data-label="RV64I equivalent">jal x0,label / beq/bne/blt/bge/bltu/bgeu</td>
        <td data-label="What it does">Jump unconditionally or branch on cmp register.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;JR&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;GE&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;loop_end&quot;}],&quot;loc&quot;:{&quot;line&quot;:16}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD</td>
        <td data-label="ZASM opcode (hex)">0x70</td>
        <td data-label="Operand shape (suggested)">LD r, x</td>
        <td data-label="WASM equivalent">local.set</td>
        <td data-label="RV64I equivalent">mv/li (addi/lui+addi)</td>
        <td data-label="What it does">Move immediate/label/memory into a register.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:10}],&quot;loc&quot;:{&quot;line&quot;:5}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD16S</td>
        <td data-label="ZASM opcode (hex)">0x74</td>
        <td data-label="Operand shape (suggested)">LD16S r, (addr)</td>
        <td data-label="WASM equivalent">i32.load16_s</td>
        <td data-label="RV64I equivalent">lh</td>
        <td data-label="What it does">Load signed 16-bit value and sign-extend to 32 bits.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD16S&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;IX&quot;},{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf16&quot;}],&quot;loc&quot;:{&quot;line&quot;:46}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD16S64</td>
        <td data-label="ZASM opcode (hex)">0x7A</td>
        <td data-label="Operand shape (suggested)">LD16S64 r, (addr)</td>
        <td data-label="WASM equivalent">i64.load16_s</td>
        <td data-label="RV64I equivalent">lh</td>
        <td data-label="What it does">Load signed 16-bit value and sign-extend to 64 bits.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD16S64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf16&quot;}],&quot;loc&quot;:{&quot;line&quot;:50}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD16U</td>
        <td data-label="ZASM opcode (hex)">0x73</td>
        <td data-label="Operand shape (suggested)">LD16U r, (addr)</td>
        <td data-label="WASM equivalent">i32.load16_u</td>
        <td data-label="RV64I equivalent">lhu</td>
        <td data-label="What it does">Load unsigned 16-bit value and zero-extend to 32 bits.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD16U&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;},{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf16&quot;}],&quot;loc&quot;:{&quot;line&quot;:45}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD16U64</td>
        <td data-label="ZASM opcode (hex)">0x79</td>
        <td data-label="Operand shape (suggested)">LD16U64 r, (addr)</td>
        <td data-label="WASM equivalent">i64.load16_u</td>
        <td data-label="RV64I equivalent">lhu</td>
        <td data-label="What it does">Load unsigned 16-bit value and zero-extend to 64 bits.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD16U64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;},{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf16&quot;}],&quot;loc&quot;:{&quot;line&quot;:51}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD32</td>
        <td data-label="ZASM opcode (hex)">0x75</td>
        <td data-label="Operand shape (suggested)">LD32 r, (addr)</td>
        <td data-label="WASM equivalent">i32.load (zero-extend to 64)</td>
        <td data-label="RV64I equivalent">lwu</td>
        <td data-label="What it does">Load 32-bit word into a register.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD32&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;},{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf32&quot;}],&quot;loc&quot;:{&quot;line&quot;:38}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD32S64</td>
        <td data-label="ZASM opcode (hex)">0x7C</td>
        <td data-label="Operand shape (suggested)">LD32S64 r, (addr)</td>
        <td data-label="WASM equivalent">i64.load32_s</td>
        <td data-label="RV64I equivalent">lw</td>
        <td data-label="What it does">Load signed 32-bit word and sign-extend to 64 bits.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD32S64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf32&quot;}],&quot;loc&quot;:{&quot;line&quot;:52}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD32U64</td>
        <td data-label="ZASM opcode (hex)">0x7B</td>
        <td data-label="Operand shape (suggested)">LD32U64 r, (addr)</td>
        <td data-label="WASM equivalent">i64.load32_u</td>
        <td data-label="RV64I equivalent">lwu</td>
        <td data-label="What it does">Load unsigned 32-bit word and zero-extend to 64 bits.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD32U64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;BC&quot;},{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf32&quot;}],&quot;loc&quot;:{&quot;line&quot;:53}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD64</td>
        <td data-label="ZASM opcode (hex)">0x76</td>
        <td data-label="Operand shape (suggested)">LD64 r, (addr)</td>
        <td data-label="WASM equivalent">i64.load</td>
        <td data-label="RV64I equivalent">ld</td>
        <td data-label="What it does">Load a 64-bit doubleword into a register.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf64&quot;}],&quot;loc&quot;:{&quot;line&quot;:43}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD8S</td>
        <td data-label="ZASM opcode (hex)">0x72</td>
        <td data-label="Operand shape (suggested)">LD8S r, (addr)</td>
        <td data-label="WASM equivalent">i32.load8_s</td>
        <td data-label="RV64I equivalent">lb</td>
        <td data-label="What it does">Load signed byte and sign-extend to 32 bits.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD8S&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;BC&quot;},{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf8&quot;}],&quot;loc&quot;:{&quot;line&quot;:42}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD8S64</td>
        <td data-label="ZASM opcode (hex)">0x78</td>
        <td data-label="Operand shape (suggested)">LD8S64 r, (addr)</td>
        <td data-label="WASM equivalent">i64.load8_s</td>
        <td data-label="RV64I equivalent">lb</td>
        <td data-label="What it does">Load signed byte and sign-extend to 64 bits.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD8S64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf8&quot;}],&quot;loc&quot;:{&quot;line&quot;:48}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD8U</td>
        <td data-label="ZASM opcode (hex)">0x71</td>
        <td data-label="Operand shape (suggested)">LD8U r, (addr)</td>
        <td data-label="WASM equivalent">i32.load8_u</td>
        <td data-label="RV64I equivalent">lbu</td>
        <td data-label="What it does">Load unsigned byte and zero-extend to 32 bits.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD8U&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;A&quot;},{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf8&quot;}],&quot;loc&quot;:{&quot;line&quot;:41}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LD8U64</td>
        <td data-label="ZASM opcode (hex)">0x77</td>
        <td data-label="Operand shape (suggested)">LD8U64 r, (addr)</td>
        <td data-label="WASM equivalent">i64.load8_u</td>
        <td data-label="RV64I equivalent">lbu</td>
        <td data-label="What it does">Load unsigned byte and zero-extend to 64 bits.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LD8U64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;},{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf8&quot;}],&quot;loc&quot;:{&quot;line&quot;:49}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LDIR</td>
        <td data-label="ZASM opcode (hex)">0x90 (pseudo)</td>
        <td data-label="Operand shape (suggested)">LDIR (DE dst, HL src, BC len)</td>
        <td data-label="WASM equivalent">memory.copy</td>
        <td data-label="RV64I equivalent">memcpy loop (pseudo)</td>
        <td data-label="What it does">Bulk copy memory via Lembeh ABI registers.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LDIR&quot;,&quot;ops&quot;:[],&quot;loc&quot;:{&quot;line&quot;:56}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LES</td>
        <td data-label="ZASM opcode (hex)">0x53</td>
        <td data-label="Operand shape (suggested)">LES HL, x</td>
        <td data-label="WASM equivalent">i32.le_s</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Signed &lt;= compare -&gt; 0/1.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LES&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:2}],&quot;loc&quot;:{&quot;line&quot;:27}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LES64</td>
        <td data-label="ZASM opcode (hex)">0x63</td>
        <td data-label="Operand shape (suggested)">LES64 HL, x</td>
        <td data-label="WASM equivalent">i64.le_s</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Signed 64-bit less-or-equal compare.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LES64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:1}],&quot;loc&quot;:{&quot;line&quot;:30}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LEU</td>
        <td data-label="ZASM opcode (hex)">0x57</td>
        <td data-label="Operand shape (suggested)">LEU HL, x</td>
        <td data-label="WASM equivalent">i32.le_u</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Unsigned &lt;= compare -&gt; 0/1.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LEU&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:2}],&quot;loc&quot;:{&quot;line&quot;:28}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LEU64</td>
        <td data-label="ZASM opcode (hex)">0x67</td>
        <td data-label="Operand shape (suggested)">LEU64 HL, x</td>
        <td data-label="WASM equivalent">i64.le_u</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Unsigned 64-bit less-or-equal compare.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LEU64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:2}],&quot;loc&quot;:{&quot;line&quot;:31}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LTS</td>
        <td data-label="ZASM opcode (hex)">0x52</td>
        <td data-label="Operand shape (suggested)">LTS HL, x</td>
        <td data-label="WASM equivalent">i32.lt_s</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Signed &lt; compare -&gt; 0/1.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LTS&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:3}],&quot;loc&quot;:{&quot;line&quot;:25}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LTS64</td>
        <td data-label="ZASM opcode (hex)">0x62</td>
        <td data-label="Operand shape (suggested)">LTS64 HL, x</td>
        <td data-label="WASM equivalent">i64.lt_s</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Signed 64-bit less-than compare (0/1 result).</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LTS64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;}],&quot;loc&quot;:{&quot;line&quot;:28}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LTU</td>
        <td data-label="ZASM opcode (hex)">0x56</td>
        <td data-label="Operand shape (suggested)">LTU HL, x</td>
        <td data-label="WASM equivalent">i32.lt_u</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Unsigned &lt; compare -&gt; 0/1.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LTU&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:3}],&quot;loc&quot;:{&quot;line&quot;:26}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">LTU64</td>
        <td data-label="ZASM opcode (hex)">0x66</td>
        <td data-label="Operand shape (suggested)">LTU64 HL, x</td>
        <td data-label="WASM equivalent">i64.lt_u</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Unsigned 64-bit less-than compare.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;LTU64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;BC&quot;}],&quot;loc&quot;:{&quot;line&quot;:29}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">MUL</td>
        <td data-label="ZASM opcode (hex)">0x12</td>
        <td data-label="Operand shape (suggested)">MUL HL, x</td>
        <td data-label="WASM equivalent">i32.mul</td>
        <td data-label="RV64I equivalent">mulw + zext.w</td>
        <td data-label="What it does">Multiply register by immediate/register.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;MUL&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:4}],&quot;loc&quot;:{&quot;line&quot;:18}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">MUL64</td>
        <td data-label="ZASM opcode (hex)">0x22</td>
        <td data-label="Operand shape (suggested)">MUL64 HL, x</td>
        <td data-label="WASM equivalent">i64.mul</td>
        <td data-label="RV64I equivalent">mul</td>
        <td data-label="What it does">Multiply a 64-bit register by immediates/registers.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;MUL64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;BC&quot;}],&quot;loc&quot;:{&quot;line&quot;:5}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">NE</td>
        <td data-label="ZASM opcode (hex)">0x51</td>
        <td data-label="Operand shape (suggested)">NE HL, x</td>
        <td data-label="WASM equivalent">i32.ne</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Compare not-equals -&gt; 0/1.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;NE&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:1}],&quot;loc&quot;:{&quot;line&quot;:22}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">NE64</td>
        <td data-label="ZASM opcode (hex)">0x61</td>
        <td data-label="Operand shape (suggested)">NE64 HL, x</td>
        <td data-label="WASM equivalent">i64.ne</td>
        <td data-label="RV64I equivalent">slt/sltu + seqz/snez (pseudo)</td>
        <td data-label="What it does">Compare 64-bit values for inequality, returning 0/1.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;NE64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:0}],&quot;loc&quot;:{&quot;line&quot;:27}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">OR</td>
        <td data-label="ZASM opcode (hex)">0x18</td>
        <td data-label="Operand shape (suggested)">OR HL, x</td>
        <td data-label="WASM equivalent">i32.or</td>
        <td data-label="RV64I equivalent">or</td>
        <td data-label="What it does">Bitwise OR register with scalar/symbol.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;OR&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:7}],&quot;loc&quot;:{&quot;line&quot;:11}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">OR64</td>
        <td data-label="ZASM opcode (hex)">0x28</td>
        <td data-label="Operand shape (suggested)">OR64 HL, x</td>
        <td data-label="WASM equivalent">i64.or</td>
        <td data-label="RV64I equivalent">or</td>
        <td data-label="What it does">Bitwise OR on 64-bit registers with immediates or symbols.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;OR64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:16}],&quot;loc&quot;:{&quot;line&quot;:13}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">POPC</td>
        <td data-label="ZASM opcode (hex)">0x37</td>
        <td data-label="Operand shape (suggested)">POPC r</td>
        <td data-label="WASM equivalent">i32.popcnt</td>
        <td data-label="RV64I equivalent">cpopw (Zbb) + zext.w</td>
        <td data-label="What it does">Count set bits in a register.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;POPC&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;}],&quot;loc&quot;:{&quot;line&quot;:35}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">POPC64</td>
        <td data-label="ZASM opcode (hex)">0x47</td>
        <td data-label="Operand shape (suggested)">POPC64 r</td>
        <td data-label="WASM equivalent">i64.popcnt</td>
        <td data-label="RV64I equivalent">cpop (Zbb)</td>
        <td data-label="What it does">Count set bits in a 64-bit register.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;POPC64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;BC&quot;}],&quot;loc&quot;:{&quot;line&quot;:40}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">PUBLIC</td>
        <td data-label="ZASM opcode (hex)">—</td>
        <td data-label="Operand shape (suggested)">PUBLIC symbol</td>
        <td data-label="WASM equivalent">export</td>
        <td data-label="RV64I equivalent">n/a (directive)</td>
        <td data-label="What it does">Mark a symbol for export from the module.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;dir&quot;,&quot;d&quot;:&quot;PUBLIC&quot;,&quot;args&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;main&quot;}],&quot;loc&quot;:{&quot;line&quot;:4}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">REMS</td>
        <td data-label="ZASM opcode (hex)">0x15</td>
        <td data-label="Operand shape (suggested)">REMS HL, x</td>
        <td data-label="WASM equivalent">i32.rem_s</td>
        <td data-label="RV64I equivalent">remw + zext.w (trap on div0) (trap on div0)</td>
        <td data-label="What it does">Signed remainder (traps like WASM).</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;REMS&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:2}],&quot;loc&quot;:{&quot;line&quot;:21}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">REMS64</td>
        <td data-label="ZASM opcode (hex)">0x25</td>
        <td data-label="Operand shape (suggested)">REMS64 HL, x</td>
        <td data-label="WASM equivalent">i64.rem_s</td>
        <td data-label="RV64I equivalent">rem (trap on div0)</td>
        <td data-label="What it does">Signed 64-bit remainder (matches WASM trapping semantics).</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;REMS64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;IX&quot;}],&quot;loc&quot;:{&quot;line&quot;:8}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">REMU</td>
        <td data-label="ZASM opcode (hex)">0x16</td>
        <td data-label="Operand shape (suggested)">REMU HL, x</td>
        <td data-label="WASM equivalent">i32.rem_u</td>
        <td data-label="RV64I equivalent">remuw + zext.w (trap on div0) (trap on div0)</td>
        <td data-label="What it does">Unsigned remainder (traps on div0).</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;REMU&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:2}],&quot;loc&quot;:{&quot;line&quot;:22}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">REMU64</td>
        <td data-label="ZASM opcode (hex)">0x26</td>
        <td data-label="Operand shape (suggested)">REMU64 HL, x</td>
        <td data-label="WASM equivalent">i64.rem_u</td>
        <td data-label="RV64I equivalent">remu (trap on div0)</td>
        <td data-label="What it does">Unsigned 64-bit remainder (traps on div0).</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;REMU64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:6}],&quot;loc&quot;:{&quot;line&quot;:9}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">RESB</td>
        <td data-label="ZASM opcode (hex)">—</td>
        <td data-label="Operand shape (suggested)">name: RESB count</td>
        <td data-label="WASM equivalent">memory reserve</td>
        <td data-label="RV64I equivalent">n/a (directive)</td>
        <td data-label="What it does">Reserve zeroed bytes in BSS-style data.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;dir&quot;,&quot;d&quot;:&quot;RESB&quot;,&quot;args&quot;:[{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:64}],&quot;loc&quot;:{&quot;line&quot;:40},&quot;name&quot;:&quot;buf&quot;}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">RET</td>
        <td data-label="ZASM opcode (hex)">0x01</td>
        <td data-label="Operand shape (suggested)">RET</td>
        <td data-label="WASM equivalent">br $exit</td>
        <td data-label="RV64I equivalent">ret (jalr x0, ra, 0)</td>
        <td data-label="What it does">Return from the current function slice.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;RET&quot;,&quot;ops&quot;:[],&quot;loc&quot;:{&quot;line&quot;:62}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">ROL</td>
        <td data-label="ZASM opcode (hex)">0x33</td>
        <td data-label="Operand shape (suggested)">ROL HL, x</td>
        <td data-label="WASM equivalent">i32.rotl</td>
        <td data-label="RV64I equivalent">rolw (Zbb) + zext.w</td>
        <td data-label="What it does">Rotate left by variable count.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ROL&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:2}],&quot;loc&quot;:{&quot;line&quot;:16}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">ROL64</td>
        <td data-label="ZASM opcode (hex)">0x43</td>
        <td data-label="Operand shape (suggested)">ROL64 HL, x</td>
        <td data-label="WASM equivalent">i64.rotl</td>
        <td data-label="RV64I equivalent">rol (Zbb)</td>
        <td data-label="What it does">Rotate a 64-bit register left by a variable count.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ROL64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:4}],&quot;loc&quot;:{&quot;line&quot;:22}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">ROR</td>
        <td data-label="ZASM opcode (hex)">0x34</td>
        <td data-label="Operand shape (suggested)">ROR HL, x</td>
        <td data-label="WASM equivalent">i32.rotr</td>
        <td data-label="RV64I equivalent">rorw (Zbb) + zext.w</td>
        <td data-label="What it does">Rotate right by variable count.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ROR&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:3}],&quot;loc&quot;:{&quot;line&quot;:17}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">SLA</td>
        <td data-label="ZASM opcode (hex)">0x30</td>
        <td data-label="Operand shape (suggested)">SLA HL, x</td>
        <td data-label="WASM equivalent">i32.shl</td>
        <td data-label="RV64I equivalent">sllw + zext.w</td>
        <td data-label="What it does">Shift left by variable count.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;SLA&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:1}],&quot;loc&quot;:{&quot;line&quot;:13}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">SLA64</td>
        <td data-label="ZASM opcode (hex)">0x40</td>
        <td data-label="Operand shape (suggested)">SLA64 HL, x</td>
        <td data-label="WASM equivalent">i64.shl</td>
        <td data-label="RV64I equivalent">sll</td>
        <td data-label="What it does">Shift a 64-bit register left by a variable count.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;SLA64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:1}],&quot;loc&quot;:{&quot;line&quot;:17}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">SRA</td>
        <td data-label="ZASM opcode (hex)">0x31</td>
        <td data-label="Operand shape (suggested)">SRA HL, x</td>
        <td data-label="WASM equivalent">i32.shr_s</td>
        <td data-label="RV64I equivalent">sraw + zext.w</td>
        <td data-label="What it does">Arithmetic shift right.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;SRA&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:1}],&quot;loc&quot;:{&quot;line&quot;:14}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">SRA64</td>
        <td data-label="ZASM opcode (hex)">0x41</td>
        <td data-label="Operand shape (suggested)">SRA64 HL, x</td>
        <td data-label="WASM equivalent">i64.shr_s</td>
        <td data-label="RV64I equivalent">sra</td>
        <td data-label="What it does">Arithmetic shift right on 64-bit registers.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;SRA64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:2}],&quot;loc&quot;:{&quot;line&quot;:18}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">SRL</td>
        <td data-label="ZASM opcode (hex)">0x32</td>
        <td data-label="Operand shape (suggested)">SRL HL, x</td>
        <td data-label="WASM equivalent">i32.shr_u</td>
        <td data-label="RV64I equivalent">srlw + zext.w</td>
        <td data-label="What it does">Logical shift right.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;SRL&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:1}],&quot;loc&quot;:{&quot;line&quot;:15}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">SRL64</td>
        <td data-label="ZASM opcode (hex)">0x42</td>
        <td data-label="Operand shape (suggested)">SRL64 HL, x</td>
        <td data-label="WASM equivalent">i64.shr_u</td>
        <td data-label="RV64I equivalent">srl</td>
        <td data-label="What it does">Logical shift right on 64-bit registers.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;SRL64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:3}],&quot;loc&quot;:{&quot;line&quot;:19}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">ST16</td>
        <td data-label="ZASM opcode (hex)">0x82</td>
        <td data-label="Operand shape (suggested)">ST16 (addr), r</td>
        <td data-label="WASM equivalent">i32.store16</td>
        <td data-label="RV64I equivalent">sh</td>
        <td data-label="What it does">Store low 16 bits of a register to memory.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ST16&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf16&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;BC&quot;}],&quot;loc&quot;:{&quot;line&quot;:44}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">ST16_64</td>
        <td data-label="ZASM opcode (hex)">0x83</td>
        <td data-label="Operand shape (suggested)">ST16_64 (addr), r</td>
        <td data-label="WASM equivalent">i64.store16</td>
        <td data-label="RV64I equivalent">sh</td>
        <td data-label="What it does">Store low 16 bits of a 64-bit register to memory.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ST16_64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf16&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;}],&quot;loc&quot;:{&quot;line&quot;:55}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">ST32</td>
        <td data-label="ZASM opcode (hex)">0x84</td>
        <td data-label="Operand shape (suggested)">ST32 (addr), r</td>
        <td data-label="WASM equivalent">i32.store</td>
        <td data-label="RV64I equivalent">sw</td>
        <td data-label="What it does">Store low 32 bits of a register to memory.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ST32&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf32&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;}],&quot;loc&quot;:{&quot;line&quot;:37}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">ST32_64</td>
        <td data-label="ZASM opcode (hex)">0x85</td>
        <td data-label="Operand shape (suggested)">ST32_64 (addr), r</td>
        <td data-label="WASM equivalent">i64.store32</td>
        <td data-label="RV64I equivalent">sw</td>
        <td data-label="What it does">Store low 32 bits of a 64-bit register to memory.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ST32_64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf32&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;BC&quot;}],&quot;loc&quot;:{&quot;line&quot;:56}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">ST64</td>
        <td data-label="ZASM opcode (hex)">0x86</td>
        <td data-label="Operand shape (suggested)">ST64 (addr), r</td>
        <td data-label="WASM equivalent">i64.store</td>
        <td data-label="RV64I equivalent">sd</td>
        <td data-label="What it does">Store a 64-bit register to memory.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ST64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf64&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;DE&quot;}],&quot;loc&quot;:{&quot;line&quot;:44}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">ST8</td>
        <td data-label="ZASM opcode (hex)">0x80</td>
        <td data-label="Operand shape (suggested)">ST8 (addr), r</td>
        <td data-label="WASM equivalent">i32.store8</td>
        <td data-label="RV64I equivalent">sb</td>
        <td data-label="What it does">Store low 8 bits of a register to memory.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ST8&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf8&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;A&quot;}],&quot;loc&quot;:{&quot;line&quot;:40}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">ST8_64</td>
        <td data-label="ZASM opcode (hex)">0x81</td>
        <td data-label="Operand shape (suggested)">ST8_64 (addr), r</td>
        <td data-label="WASM equivalent">i64.store8</td>
        <td data-label="RV64I equivalent">sb</td>
        <td data-label="What it does">Store low 8 bits of a 64-bit register to memory.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ST8_64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;mem&quot;,&quot;base&quot;:&quot;buf8&quot;},{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;}],&quot;loc&quot;:{&quot;line&quot;:54}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">STR</td>
        <td data-label="ZASM opcode (hex)">—</td>
        <td data-label="Operand shape (suggested)">name: STR arg[, ...]</td>
        <td data-label="WASM equivalent">data bytes</td>
        <td data-label="RV64I equivalent">n/a (directive)</td>
        <td data-label="What it does">Emit string/byte literals (null-free).</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;dir&quot;,&quot;d&quot;:&quot;STR&quot;,&quot;args&quot;:[{&quot;t&quot;:&quot;str&quot;,&quot;v&quot;:&quot;Fizz&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:10}],&quot;loc&quot;:{&quot;line&quot;:10},&quot;name&quot;:&quot;msg&quot;}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">ROR64</td>
        <td data-label="ZASM opcode (hex)">0x44</td>
        <td data-label="Operand shape (suggested)">ROR64 HL, x</td>
        <td data-label="WASM equivalent">i64.rotr</td>
        <td data-label="RV64I equivalent">ror (Zbb)</td>
        <td data-label="What it does">Rotate a 64-bit register right by a variable count.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;ROR64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:5}],&quot;loc&quot;:{&quot;line&quot;:23}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">SUB</td>
        <td data-label="ZASM opcode (hex)">0x11</td>
        <td data-label="Operand shape (suggested)">SUB HL, x</td>
        <td data-label="WASM equivalent">i32.sub</td>
        <td data-label="RV64I equivalent">subw + zext.w</td>
        <td data-label="What it does">Subtract immediate values or DE from HL.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;SUB&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:1}],&quot;loc&quot;:{&quot;line&quot;:8}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">SUB64</td>
        <td data-label="ZASM opcode (hex)">0x21</td>
        <td data-label="Operand shape (suggested)">SUB64 HL, x</td>
        <td data-label="WASM equivalent">i64.sub</td>
        <td data-label="RV64I equivalent">sub</td>
        <td data-label="What it does">Subtract 64-bit immediates or DE from HL.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;SUB64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:1}],&quot;loc&quot;:{&quot;line&quot;:4}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">XOR</td>
        <td data-label="ZASM opcode (hex)">0x19</td>
        <td data-label="Operand shape (suggested)">XOR HL, x</td>
        <td data-label="WASM equivalent">i32.xor</td>
        <td data-label="RV64I equivalent">xor</td>
        <td data-label="What it does">Bitwise XOR register with scalar/symbol.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;XOR&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:1}],&quot;loc&quot;:{&quot;line&quot;:12}}</pre></td>
      </tr>
      <tr>
        <td data-label="ZASM mnemonic">XOR64</td>
        <td data-label="ZASM opcode (hex)">0x29</td>
        <td data-label="Operand shape (suggested)">XOR64 HL, x</td>
        <td data-label="WASM equivalent">i64.xor</td>
        <td data-label="RV64I equivalent">xor</td>
        <td data-label="What it does">Bitwise XOR for 64-bit registers.</td>
        <td data-label="JSONL"><pre>{&quot;ir&quot;:&quot;zasm-v1.0&quot;,&quot;k&quot;:&quot;instr&quot;,&quot;m&quot;:&quot;XOR64&quot;,&quot;ops&quot;:[{&quot;t&quot;:&quot;sym&quot;,&quot;v&quot;:&quot;HL&quot;},{&quot;t&quot;:&quot;num&quot;,&quot;v&quot;:255}],&quot;loc&quot;:{&quot;line&quot;:14}}</pre></td>
      </tr>
    </tbody>
  </table>
</body>
</html>
