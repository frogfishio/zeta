unit types_vector_hashmap_demo target host
@mod main

@include "../types/vector.sir"
@include "../types/hashmap.sir"

fn store_ptr(dst:ptr, v:ptr) -> i32
  store.i64(dst, ptr.to_i64(v)) +align=1
  return 0:i32
end

fn load_ptr(src:ptr) -> ptr
  let v: i64 = load.i64(src) +align=1
  return ptr.from_i64(v)
end

fn main() -> i32 public
  ;; --- vector(i32) ---
  let vec: ptr = vector_new(4:i32, 2:i32)
  let tmp: ptr = zi_alloc(4:i32)
  store.i32(tmp, 10:i32)
  let _: i32 = vector_push_copy(vec, tmp)
  store.i32(tmp, 20:i32)
  let _: i32 = vector_push_copy(vec, tmp)
  store.i32(tmp, 30:i32)
  let _: i32 = vector_push_copy(vec, tmp)

  let ok_len: bool = i32.cmp.eq(vector_len(vec), 3:i32)
  let p0: ptr = vector_get_ptr(vec, 0:i32)
  let p1: ptr = vector_get_ptr(vec, 1:i32)
  let p2: ptr = vector_get_ptr(vec, 2:i32)
  let ok_vals: bool = bool.and(i32.cmp.eq(load.i32(p0), 10:i32),
                       bool.and(i32.cmp.eq(load.i32(p1), 20:i32), i32.cmp.eq(load.i32(p2), 30:i32)))

  ;; --- hashmap(bytes->ptr) ---
  let map: ptr = hashmap_new(8:i32)
  let box1: ptr = zi_alloc(4:i32)
  let box2: ptr = zi_alloc(4:i32)
  store.i32(box1, 111:i32)
  store.i32(box2, 222:i32)

  let put1: i32 = hashmap_put(map, "foo", 3:i32, box1)
  let put2: i32 = hashmap_put(map, "foo", 3:i32, box2)

  let out: ptr = zi_alloc(8:i32)
  let got: i32 = hashmap_get(map, "foo", 3:i32, out)
  let gotp: ptr = load_ptr(out)
  let ok_get: bool = bool.and(i32.cmp.eq(got, 1:i32), i32.cmp.eq(load.i32(gotp), 222:i32))

  let del1: i32 = hashmap_del(map, "foo", 3:i32)
  let got2: i32 = hashmap_get(map, "foo", 3:i32, out)
  let ok_del: bool = bool.and(i32.cmp.eq(del1, 1:i32), i32.cmp.eq(got2, 0:i32))

  ;; --- iteration smoke test (insert 2 keys, walk count==2) ---
  let _: i32 = hashmap_put(map, "a", 1:i32, box1)
  let _: i32 = hashmap_put(map, "b", 1:i32, box2)
  let next_idx: ptr = zi_alloc(4:i32)
  let keyp_out: ptr = zi_alloc(8:i32)
  let keyn_out: ptr = zi_alloc(4:i32)
  let valp_out: ptr = zi_alloc(8:i32)

  let found1: i32 = hashmap_iter_next(map, 0:i32, next_idx, keyp_out, keyn_out, valp_out)
  let idx2: i32 = load.i32(next_idx)
  let found2: i32 = hashmap_iter_next(map, idx2, next_idx, keyp_out, keyn_out, valp_out)
  let idx3: i32 = load.i32(next_idx)
  let found3: i32 = hashmap_iter_next(map, idx3, next_idx, keyp_out, keyn_out, valp_out)
  let ok_iter: bool = bool.and(i32.cmp.eq(found1, 1:i32), bool.and(i32.cmp.eq(found2, 1:i32), i32.cmp.eq(found3, 0:i32)))

  ;; cleanup
  let _: i32 = zi_free(tmp)
  let _: i32 = zi_free(out)
  let _: i32 = zi_free(next_idx)
  let _: i32 = zi_free(keyp_out)
  let _: i32 = zi_free(keyn_out)
  let _: i32 = zi_free(valp_out)

  let _: i32 = vector_free(vec)
  let _: i32 = hashmap_free(map)
  let _: i32 = zi_free(box1)
  let _: i32 = zi_free(box2)

  let ok_puts: bool = bool.and(i32.cmp.eq(put1, 0:i32), i32.cmp.eq(put2, 1:i32))
  let ok_all: bool = bool.and(ok_len, bool.and(ok_vals, bool.and(ok_puts, bool.and(ok_get, bool.and(ok_del, ok_iter)))))
  return select(i32, ok_all, 0:i32, 1:i32)
end
