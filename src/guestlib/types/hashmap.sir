@mod hashmap

@include "../include/zabi_externs.sir"

;; A tiny open-addressing hash map.
;; Keys are byte strings (ptr + len). Values are stored as `ptr`.
;;
;; Map header layout (24 bytes):
;;  0: i32 size       (full entries)
;;  4: i32 cap        (power of 2)
;;  8: i32 tomb       (tombstones)
;; 12: i32 reserved
;; 16: i64 table_ptr
;;
;; Table entry layout (32 bytes):
;;  0: u8 state (0 empty, 1 full, 2 tomb)
;;  4: i32 hash
;;  8: i64 key_ptr
;; 16: i32 key_len
;; 24: i64 val_ptr

fn hashmap_store_ptr(dst:ptr, v:ptr) -> i32
  store.i64(dst, ptr.to_i64(v)) +align=1
  return 0:i32
end

fn hashmap_load_ptr(src:ptr) -> ptr
  let v: i64 = load.i64(src) +align=1
  return ptr.from_i64(v)
end

fn hashmap_hdr_size() -> i32
  return 24:i32
end

fn hashmap_entry_size() -> i32
  return 32:i32
end

fn hashmap_size(m:ptr) -> i32
  return load.i32(ptr.offset(i8, m, 0:i64))
end

fn hashmap_cap(m:ptr) -> i32
  return load.i32(ptr.offset(i8, m, 4:i64))
end

fn hashmap_tomb(m:ptr) -> i32
  return load.i32(ptr.offset(i8, m, 8:i64))
end

fn hashmap_table(m:ptr) -> ptr
  return ptr.from_i64(load.i64(ptr.offset(i8, m, 16:i64)) +align=1)
end

fn hashmap_set_size(m:ptr, v:i32) -> i32
  store.i32(ptr.offset(i8, m, 0:i64), v)
  return 0:i32
end

fn hashmap_set_cap(m:ptr, v:i32) -> i32
  store.i32(ptr.offset(i8, m, 4:i64), v)
  return 0:i32
end

fn hashmap_set_tomb(m:ptr, v:i32) -> i32
  store.i32(ptr.offset(i8, m, 8:i64), v)
  return 0:i32
end

fn hashmap_set_table(m:ptr, t:ptr) -> i32
  store.i64(ptr.offset(i8, m, 16:i64), ptr.to_i64(t)) +align=1
  return 0:i32
end

fn hashmap_entry_ptr(table:ptr, idx:i32) -> ptr
  return ptr.offset(i8, table, i32.mul(idx, hashmap_entry_size()))
end

fn hashmap_bytes_eq(a:ptr, b:ptr, n:i32) -> bool
  block entry
    term.br to loop args:[0:i32, true]
  end

  block loop(i:i32, ok:bool)
    let i_lt: bool = i32.cmp.slt(i, n)
    let cont: bool = bool.and(ok, i_lt)
    term.cbr cond:cont,
      then:body args:[i],
      else:exit args:[ok]
  end

  block body(i:i32)
    let av: i8 = load.i8(ptr.offset(i8, a, i))
    let bv: i8 = load.i8(ptr.offset(i8, b, i))
    let ok2: bool = i32.cmp.eq(i32.zext.i8(av), i32.zext.i8(bv))
    term.br to loop args:[i32.add(i, 1:i32), ok2]
  end

  block exit(ok:bool)
    term.ret value:ok
  end
end

fn hashmap_hash_bytes(p:ptr, n:i32) -> i32
  ;; FNV-1a 32-bit
  ;; 2166136261u interpreted as signed i32
  block entry
    term.br to loop args:[0:i32, -2128831035:i32]
  end

  block loop(i:i32, h:i32)
    let cont: bool = i32.cmp.slt(i, n)
    term.cbr cond:cont,
      then:body args:[i, h],
      else:done args:[h]
  end

  block body(i:i32, h:i32)
    let b: i8 = load.i8(ptr.offset(i8, p, i))
    let h2: i32 = i32.xor(h, i32.zext.i8(b))
    let h3: i32 = i32.mul(h2, 16777619:i32)
    term.br to loop args:[i32.add(i, 1:i32), h3]
  end

  block done(h:i32)
    term.ret value:h
  end
end

fn hashmap_round_up_pow2(x:i32) -> i32
  block entry
    let want: i32 = select(i32, i32.cmp.sgt(x, 8:i32), x, 8:i32)
    term.br to loop args:[8:i32, want]
  end

  block loop(cap:i32, want:i32)
    let ok: bool = i32.cmp.sge(cap, want)
    term.cbr cond:ok,
      then:done args:[cap],
      else:cont args:[cap, want]
  end

  block cont(cap:i32, want:i32)
    term.br to loop args:[i32.mul(cap, 2:i32), want]
  end

  block done(cap:i32)
    term.ret value:cap
  end
end

fn hashmap_put_raw(table:ptr, cap:i32, hash:i32, key_ptr:ptr, key_len:i32, val_ptr:ptr) -> i32
  ;; Inserts into a table; no resizing; assumes there is at least one empty slot.
  block entry
    let mask: i32 = i32.sub(cap, 1:i32)
    let idx0: i32 = i32.and(hash, mask)
    term.br to loop args:[idx0, 0:i32, mask]
  end

  block loop(idx:i32, probe:i32, mask:i32)
    let done: bool = i32.cmp.sge(probe, cap)
    term.cbr cond:done,
      then:fail,
      else:step args:[idx, probe, mask]
  end

  block step(idx:i32, probe:i32, mask:i32)
    let e: ptr = hashmap_entry_ptr(table, idx)
    let st: i32 = i32.zext.i8(load.i8(ptr.offset(i8, e, 0:i64)))
    let empty: bool = i32.cmp.eq(st, 0:i32)
    term.cbr cond:empty,
      then:ins args:[e],
      else:next args:[idx, probe, mask]
  end

  block ins(e:ptr)
    store.i8(ptr.offset(i8, e, 0:i64), 1:i8)
    store.i32(ptr.offset(i8, e, 4:i64), hash)
    store.i64(ptr.offset(i8, e, 8:i64), ptr.to_i64(key_ptr)) +align=1
    store.i32(ptr.offset(i8, e, 16:i64), key_len)
    store.i64(ptr.offset(i8, e, 24:i64), ptr.to_i64(val_ptr)) +align=1
    term.ret value:0:i32
  end

  block next(idx:i32, probe:i32, mask:i32)
    let idx2: i32 = i32.and(i32.add(idx, 1:i32), mask)
    term.br to loop args:[idx2, i32.add(probe, 1:i32), mask]
  end

  block fail
    term.ret value:-1:i32
  end
end

fn hashmap_rehash(m:ptr, new_cap_in:i32) -> i32
  ;; Rebuilds the table into a new capacity and clears tombstones.
  block entry
    let old_cap: i32 = hashmap_cap(m)
    let old_table: ptr = hashmap_table(m)
    let new_cap: i32 = hashmap_round_up_pow2(new_cap_in)
    let new_table: ptr = zi_alloc(i32.mul(new_cap, hashmap_entry_size()))
    mem.fill(new_table, 0:i8, i32.mul(new_cap, hashmap_entry_size())) +align=1
    term.br to loop args:[0:i32, old_cap, old_table, new_cap, new_table]
  end

  block loop(i:i32, old_cap:i32, old_table:ptr, new_cap:i32, new_table:ptr)
    let done: bool = i32.cmp.sge(i, old_cap)
    term.cbr cond:done,
      then:finish args:[old_table, new_cap, new_table],
      else:step args:[i, old_cap, old_table, new_cap, new_table]
  end

  block step(i:i32, old_cap:i32, old_table:ptr, new_cap:i32, new_table:ptr)
    let e: ptr = hashmap_entry_ptr(old_table, i)
    let st: i32 = i32.zext.i8(load.i8(ptr.offset(i8, e, 0:i64)))
    let full: bool = i32.cmp.eq(st, 1:i32)
    term.cbr cond:full,
      then:move args:[i, old_cap, old_table, new_cap, new_table, e],
      else:cont args:[i, old_cap, old_table, new_cap, new_table]
  end

  block move(i:i32, old_cap:i32, old_table:ptr, new_cap:i32, new_table:ptr, e:ptr)
    let h: i32 = load.i32(ptr.offset(i8, e, 4:i64))
    let kptr: ptr = ptr.from_i64(load.i64(ptr.offset(i8, e, 8:i64)) +align=1)
    let klen: i32 = load.i32(ptr.offset(i8, e, 16:i64))
    let vptr: ptr = ptr.from_i64(load.i64(ptr.offset(i8, e, 24:i64)) +align=1)
    let _: i32 = hashmap_put_raw(new_table, new_cap, h, kptr, klen, vptr)
    term.br to cont args:[i, old_cap, old_table, new_cap, new_table]
  end

  block cont(i:i32, old_cap:i32, old_table:ptr, new_cap:i32, new_table:ptr)
    term.br to loop args:[i32.add(i, 1:i32), old_cap, old_table, new_cap, new_table]
  end

  block finish(old_table:ptr, new_cap:i32, new_table:ptr)
    let _: i32 = zi_free(old_table)
    let _: i32 = hashmap_set_table(m, new_table)
    let _: i32 = hashmap_set_cap(m, new_cap)
    let _: i32 = hashmap_set_tomb(m, 0:i32)
    term.ret value:0:i32
  end
end

fn hashmap_new(initial_cap:i32) -> ptr
  let cap: i32 = hashmap_round_up_pow2(initial_cap)
  let hdr: ptr = zi_alloc(hashmap_hdr_size())
  let table: ptr = zi_alloc(i32.mul(cap, hashmap_entry_size()))
  mem.fill(table, 0:i8, i32.mul(cap, hashmap_entry_size())) +align=1

  store.i32(ptr.offset(i8, hdr, 0:i64), 0:i32)
  store.i32(ptr.offset(i8, hdr, 4:i64), cap)
  store.i32(ptr.offset(i8, hdr, 8:i64), 0:i32)
  store.i32(ptr.offset(i8, hdr, 12:i64), 0:i32)
  let _: i32 = hashmap_set_table(hdr, table)
  return hdr
end

fn hashmap_free(m:ptr) -> i32
  let t: ptr = hashmap_table(m)
  let _: i32 = zi_free(t)
  let _: i32 = zi_free(m)
  return 0:i32
end

fn hashmap_should_grow(m:ptr) -> bool
  let sz: i32 = hashmap_size(m)
  let tb: i32 = hashmap_tomb(m)
  let cap: i32 = hashmap_cap(m)
  let used: i32 = i32.add(sz, tb)
  ;; (used+1) / cap >= 0.7  =>  (used+1)*10 >= cap*7
  return i32.cmp.sge(i32.mul(i32.add(used, 1:i32), 10:i32), i32.mul(cap, 7:i32))
end

fn hashmap_get(m:ptr, key_ptr:ptr, key_len:i32, out_val_ptr:ptr) -> i32
  block entry
    let cap: i32 = hashmap_cap(m)
    let table: ptr = hashmap_table(m)
    let h: i32 = hashmap_hash_bytes(key_ptr, key_len)
    let mask: i32 = i32.sub(cap, 1:i32)
    let idx0: i32 = i32.and(h, mask)
    term.br to loop args:[idx0, 0:i32, cap, table, mask, h, key_ptr, key_len, out_val_ptr]
  end

  block loop(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, key_ptr:ptr, key_len:i32, out_val_ptr:ptr)
    let done: bool = i32.cmp.sge(probe, cap)
    term.cbr cond:done,
      then:not_found args:[out_val_ptr],
      else:step args:[idx, probe, cap, table, mask, h, key_ptr, key_len, out_val_ptr]
  end

  block step(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, key_ptr:ptr, key_len:i32, out_val_ptr:ptr)
    let e: ptr = hashmap_entry_ptr(table, idx)
    let st: i32 = i32.zext.i8(load.i8(ptr.offset(i8, e, 0:i64)))
    let empty: bool = i32.cmp.eq(st, 0:i32)
    term.cbr cond:empty,
      then:not_found args:[out_val_ptr],
      else:maybe_full args:[idx, probe, cap, table, mask, h, key_ptr, key_len, out_val_ptr, e, st]
  end

  block maybe_full(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, key_ptr:ptr, key_len:i32, out_val_ptr:ptr, e:ptr, st:i32)
    let full: bool = i32.cmp.eq(st, 1:i32)
    term.cbr cond:full,
      then:check_hash args:[idx, probe, cap, table, mask, h, key_ptr, key_len, out_val_ptr, e],
      else:next args:[idx, probe, cap, table, mask, h, key_ptr, key_len, out_val_ptr]
  end

  block check_hash(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, key_ptr:ptr, key_len:i32, out_val_ptr:ptr, e:ptr)
    let eh: i32 = load.i32(ptr.offset(i8, e, 4:i64))
    let hmatch: bool = i32.cmp.eq(eh, h)
    term.cbr cond:hmatch,
      then:check_len args:[idx, probe, cap, table, mask, h, key_ptr, key_len, out_val_ptr, e],
      else:next args:[idx, probe, cap, table, mask, h, key_ptr, key_len, out_val_ptr]
  end

  block check_len(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, key_ptr:ptr, key_len:i32, out_val_ptr:ptr, e:ptr)
    let eklen: i32 = load.i32(ptr.offset(i8, e, 16:i64))
    let lmatch: bool = i32.cmp.eq(eklen, key_len)
    term.cbr cond:lmatch,
      then:check_bytes args:[idx, probe, cap, table, mask, h, key_ptr, key_len, out_val_ptr, e],
      else:next args:[idx, probe, cap, table, mask, h, key_ptr, key_len, out_val_ptr]
  end

  block check_bytes(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, key_ptr:ptr, key_len:i32, out_val_ptr:ptr, e:ptr)
    let ekptr: ptr = ptr.from_i64(load.i64(ptr.offset(i8, e, 8:i64)) +align=1)
    let eq: bool = hashmap_bytes_eq(ekptr, key_ptr, key_len)
    term.cbr cond:eq,
      then:found args:[e, out_val_ptr],
      else:next args:[idx, probe, cap, table, mask, h, key_ptr, key_len, out_val_ptr]
  end

  block found(e:ptr, out_val_ptr:ptr)
    let vptr: ptr = ptr.from_i64(load.i64(ptr.offset(i8, e, 24:i64)) +align=1)
    let _: i32 = hashmap_store_ptr(out_val_ptr, vptr)
    term.ret value:1:i32
  end

  block next(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, key_ptr:ptr, key_len:i32, out_val_ptr:ptr)
    let idx2: i32 = i32.and(i32.add(idx, 1:i32), mask)
    term.br to loop args:[idx2, i32.add(probe, 1:i32), cap, table, mask, h, key_ptr, key_len, out_val_ptr]
  end

  block not_found(out_val_ptr:ptr)
    let _: i32 = hashmap_store_ptr(out_val_ptr, ptr.from_i64(0:i64))
    term.ret value:0:i32
  end
end

fn hashmap_put(m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr) -> i32
  ;; Returns 0 on insert, 1 on update.
  block entry
    let grow: bool = hashmap_should_grow(m)
    term.cbr cond:grow,
      then:grow args:[m, key_ptr, key_len, val_ptr],
      else:go args:[m, key_ptr, key_len, val_ptr]
  end

  block grow(m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr)
    let _: i32 = hashmap_rehash(m, i32.mul(hashmap_cap(m), 2:i32))
    term.br to go args:[m, key_ptr, key_len, val_ptr]
  end

  block go(m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr)
    let cap: i32 = hashmap_cap(m)
    let table: ptr = hashmap_table(m)
    let h: i32 = hashmap_hash_bytes(key_ptr, key_len)
    let mask: i32 = i32.sub(cap, 1:i32)
    let idx0: i32 = i32.and(h, mask)
    term.br to loop args:[idx0, 0:i32, -1:i32, cap, table, mask, h, m, key_ptr, key_len, val_ptr]
  end

  block loop(idx:i32, probe:i32, first_tomb:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr)
    let done: bool = i32.cmp.sge(probe, cap)
    term.cbr cond:done,
      then:fail,
      else:step args:[idx, probe, first_tomb, cap, table, mask, h, m, key_ptr, key_len, val_ptr]
  end

  block step(idx:i32, probe:i32, first_tomb:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr)
    let e: ptr = hashmap_entry_ptr(table, idx)
    let st: i32 = i32.zext.i8(load.i8(ptr.offset(i8, e, 0:i64)))

    let empty: bool = i32.cmp.eq(st, 0:i32)
    term.cbr cond:empty,
      then:insert args:[idx, first_tomb, table, h, m, key_ptr, key_len, val_ptr],
      else:check_tomb args:[idx, probe, first_tomb, cap, table, mask, h, m, key_ptr, key_len, val_ptr, e, st]
  end

  block insert(idx:i32, first_tomb:i32, table:ptr, h:i32, m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr)
    let use_tomb: bool = i32.cmp.sge(first_tomb, 0:i32)
    let dst_idx: i32 = select(i32, use_tomb, first_tomb, idx)
    let dst: ptr = hashmap_entry_ptr(table, dst_idx)

    store.i8(ptr.offset(i8, dst, 0:i64), 1:i8)
    store.i32(ptr.offset(i8, dst, 4:i64), h)
    store.i64(ptr.offset(i8, dst, 8:i64), ptr.to_i64(key_ptr)) +align=1
    store.i32(ptr.offset(i8, dst, 16:i64), key_len)
    store.i64(ptr.offset(i8, dst, 24:i64), ptr.to_i64(val_ptr)) +align=1

    let sz: i32 = hashmap_size(m)
    let _: i32 = hashmap_set_size(m, i32.add(sz, 1:i32))
    let tb: i32 = hashmap_tomb(m)
    let tb2: i32 = select(i32, use_tomb, i32.sub(tb, 1:i32), tb)
    let _: i32 = hashmap_set_tomb(m, tb2)
    term.ret value:0:i32
  end

  block check_tomb(idx:i32, probe:i32, first_tomb:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr, e:ptr, st:i32)
    let is_tomb: bool = i32.cmp.eq(st, 2:i32)
    term.cbr cond:is_tomb,
      then:set_tomb args:[idx, probe, first_tomb, cap, table, mask, h, m, key_ptr, key_len, val_ptr],
      else:maybe_full args:[idx, probe, first_tomb, cap, table, mask, h, m, key_ptr, key_len, val_ptr, e, st]
  end

  block set_tomb(idx:i32, probe:i32, first_tomb:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr)
    let no_tomb: bool = i32.cmp.slt(first_tomb, 0:i32)
    let first2: i32 = select(i32, no_tomb, idx, first_tomb)
    term.br to next args:[idx, probe, first2, cap, table, mask, h, m, key_ptr, key_len, val_ptr]
  end

  block maybe_full(idx:i32, probe:i32, first_tomb:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr, e:ptr, st:i32)
    let full: bool = i32.cmp.eq(st, 1:i32)
    term.cbr cond:full,
      then:check_hash args:[idx, probe, first_tomb, cap, table, mask, h, m, key_ptr, key_len, val_ptr, e],
      else:next args:[idx, probe, first_tomb, cap, table, mask, h, m, key_ptr, key_len, val_ptr]
  end

  block check_hash(idx:i32, probe:i32, first_tomb:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr, e:ptr)
    let eh: i32 = load.i32(ptr.offset(i8, e, 4:i64))
    let hmatch: bool = i32.cmp.eq(eh, h)
    term.cbr cond:hmatch,
      then:check_len args:[idx, probe, first_tomb, cap, table, mask, h, m, key_ptr, key_len, val_ptr, e],
      else:next args:[idx, probe, first_tomb, cap, table, mask, h, m, key_ptr, key_len, val_ptr]
  end

  block check_len(idx:i32, probe:i32, first_tomb:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr, e:ptr)
    let eklen: i32 = load.i32(ptr.offset(i8, e, 16:i64))
    let lmatch: bool = i32.cmp.eq(eklen, key_len)
    term.cbr cond:lmatch,
      then:check_bytes args:[idx, probe, first_tomb, cap, table, mask, h, m, key_ptr, key_len, val_ptr, e],
      else:next args:[idx, probe, first_tomb, cap, table, mask, h, m, key_ptr, key_len, val_ptr]
  end

  block check_bytes(idx:i32, probe:i32, first_tomb:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr, e:ptr)
    let ekptr: ptr = ptr.from_i64(load.i64(ptr.offset(i8, e, 8:i64)) +align=1)
    let eq: bool = hashmap_bytes_eq(ekptr, key_ptr, key_len)
    term.cbr cond:eq,
      then:update args:[e, val_ptr],
      else:next args:[idx, probe, first_tomb, cap, table, mask, h, m, key_ptr, key_len, val_ptr]
  end

  block update(e:ptr, val_ptr:ptr)
    store.i64(ptr.offset(i8, e, 24:i64), ptr.to_i64(val_ptr)) +align=1
    term.ret value:1:i32
  end

  block next(idx:i32, probe:i32, first_tomb:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr)
    let idx2: i32 = i32.and(i32.add(idx, 1:i32), mask)
    term.br to loop args:[idx2, i32.add(probe, 1:i32), first_tomb, cap, table, mask, h, m, key_ptr, key_len, val_ptr]
  end

  block fail
    term.ret value:-1:i32
  end
end

fn hashmap_put_copy_key(m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr) -> i32
  ;; Like hashmap_put, but copies the key bytes into an owned allocation on insert.
  ;; On update, it does not allocate and does not change the key pointer.
  block entry
    let out: ptr = zi_alloc(8:i32)
    let found: i32 = hashmap_get(m, key_ptr, key_len, out)
    let _: i32 = zi_free(out)
    let is_found: bool = i32.cmp.eq(found, 1:i32)
    term.cbr cond:is_found,
      then:update args:[m, key_ptr, key_len, val_ptr],
      else:insert args:[m, key_ptr, key_len, val_ptr]
  end

  block update(m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr)
    term.ret value:hashmap_put(m, key_ptr, key_len, val_ptr)
  end

  block insert(m:ptr, key_ptr:ptr, key_len:i32, val_ptr:ptr)
    let kcopy: ptr = zi_alloc(key_len)
    mem.copy(kcopy, key_ptr, key_len) +alignDst=1 +alignSrc=1 +overlap=disallow
    term.ret value:hashmap_put(m, kcopy, key_len, val_ptr)
  end
end

fn hashmap_del(m:ptr, key_ptr:ptr, key_len:i32) -> i32
  block entry
    let cap: i32 = hashmap_cap(m)
    let table: ptr = hashmap_table(m)
    let h: i32 = hashmap_hash_bytes(key_ptr, key_len)
    let mask: i32 = i32.sub(cap, 1:i32)
    let idx0: i32 = i32.and(h, mask)
    term.br to loop args:[idx0, 0:i32, cap, table, mask, h, m, key_ptr, key_len]
  end

  block loop(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32)
    let done: bool = i32.cmp.sge(probe, cap)
    term.cbr cond:done,
      then:not_found,
      else:step args:[idx, probe, cap, table, mask, h, m, key_ptr, key_len]
  end

  block step(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32)
    let e: ptr = hashmap_entry_ptr(table, idx)
    let st: i32 = i32.zext.i8(load.i8(ptr.offset(i8, e, 0:i64)))
    let empty: bool = i32.cmp.eq(st, 0:i32)
    term.cbr cond:empty,
      then:not_found,
      else:maybe_full args:[idx, probe, cap, table, mask, h, m, key_ptr, key_len, e, st]
  end

  block maybe_full(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, e:ptr, st:i32)
    let full: bool = i32.cmp.eq(st, 1:i32)
    term.cbr cond:full,
      then:check_hash args:[idx, probe, cap, table, mask, h, m, key_ptr, key_len, e],
      else:next args:[idx, probe, cap, table, mask, h, m, key_ptr, key_len]
  end

  block check_hash(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, e:ptr)
    let eh: i32 = load.i32(ptr.offset(i8, e, 4:i64))
    let hmatch: bool = i32.cmp.eq(eh, h)
    term.cbr cond:hmatch,
      then:check_len args:[idx, probe, cap, table, mask, h, m, key_ptr, key_len, e],
      else:next args:[idx, probe, cap, table, mask, h, m, key_ptr, key_len]
  end

  block check_len(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, e:ptr)
    let eklen: i32 = load.i32(ptr.offset(i8, e, 16:i64))
    let lmatch: bool = i32.cmp.eq(eklen, key_len)
    term.cbr cond:lmatch,
      then:check_bytes args:[idx, probe, cap, table, mask, h, m, key_ptr, key_len, e],
      else:next args:[idx, probe, cap, table, mask, h, m, key_ptr, key_len]
  end

  block check_bytes(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32, e:ptr)
    let ekptr: ptr = ptr.from_i64(load.i64(ptr.offset(i8, e, 8:i64)) +align=1)
    let eq: bool = hashmap_bytes_eq(ekptr, key_ptr, key_len)
    term.cbr cond:eq,
      then:del args:[e, m],
      else:next args:[idx, probe, cap, table, mask, h, m, key_ptr, key_len]
  end

  block del(e:ptr, m:ptr)
    store.i8(ptr.offset(i8, e, 0:i64), 2:i8)
    let sz: i32 = hashmap_size(m)
    let _: i32 = hashmap_set_size(m, i32.sub(sz, 1:i32))
    let tb: i32 = hashmap_tomb(m)
    let _: i32 = hashmap_set_tomb(m, i32.add(tb, 1:i32))
    term.ret value:1:i32
  end

  block next(idx:i32, probe:i32, cap:i32, table:ptr, mask:i32, h:i32, m:ptr, key_ptr:ptr, key_len:i32)
    let idx2: i32 = i32.and(i32.add(idx, 1:i32), mask)
    term.br to loop args:[idx2, i32.add(probe, 1:i32), cap, table, mask, h, m, key_ptr, key_len]
  end

  block not_found
    term.ret value:0:i32
  end
end

fn hashmap_iter_next(m:ptr, start_idx:i32, out_next_idx:ptr, out_key_ptr:ptr, out_key_len:ptr, out_val_ptr:ptr) -> i32
  block entry
    let cap: i32 = hashmap_cap(m)
    let table: ptr = hashmap_table(m)
    term.br to loop args:[start_idx, cap, table, out_next_idx, out_key_ptr, out_key_len, out_val_ptr]
  end

  block loop(i:i32, cap:i32, table:ptr, out_next_idx:ptr, out_key_ptr:ptr, out_key_len:ptr, out_val_ptr:ptr)
    let done: bool = i32.cmp.sge(i, cap)
    term.cbr cond:done,
      then:done,
      else:step args:[i, cap, table, out_next_idx, out_key_ptr, out_key_len, out_val_ptr]
  end

  block step(i:i32, cap:i32, table:ptr, out_next_idx:ptr, out_key_ptr:ptr, out_key_len:ptr, out_val_ptr:ptr)
    let e: ptr = hashmap_entry_ptr(table, i)
    let st: i32 = i32.zext.i8(load.i8(ptr.offset(i8, e, 0:i64)))
    let full: bool = i32.cmp.eq(st, 1:i32)
    term.cbr cond:full,
      then:emit args:[i, e, out_next_idx, out_key_ptr, out_key_len, out_val_ptr],
      else:cont args:[i, cap, table, out_next_idx, out_key_ptr, out_key_len, out_val_ptr]
  end

  block emit(i:i32, e:ptr, out_next_idx:ptr, out_key_ptr:ptr, out_key_len:ptr, out_val_ptr:ptr)
    let kptr: ptr = ptr.from_i64(load.i64(ptr.offset(i8, e, 8:i64)) +align=1)
    let klen: i32 = load.i32(ptr.offset(i8, e, 16:i64))
    let vptr: ptr = ptr.from_i64(load.i64(ptr.offset(i8, e, 24:i64)) +align=1)

    store.i32(out_next_idx, i32.add(i, 1:i32))
    let _: i32 = hashmap_store_ptr(out_key_ptr, kptr)
    store.i32(out_key_len, klen)
    let _: i32 = hashmap_store_ptr(out_val_ptr, vptr)
    term.ret value:1:i32
  end

  block cont(i:i32, cap:i32, table:ptr, out_next_idx:ptr, out_key_ptr:ptr, out_key_len:ptr, out_val_ptr:ptr)
    term.br to loop args:[i32.add(i, 1:i32), cap, table, out_next_idx, out_key_ptr, out_key_len, out_val_ptr]
  end

  block done
    term.ret value:0:i32
  end
end
