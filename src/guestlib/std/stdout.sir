@mod stdout

@include "../include/zabi_externs.sir"

;; Minimal stdout/stderr helpers.
;; Hosted zABI installs stdio handles: 0=stdin, 1=stdout, 2=stderr.
;;
;; Usage (preferred / “golden” entrypoints):
;;
;;   - stdout_write(buf, len) / stderr_write(buf, len)
;;       Lowest-level write of raw bytes.
;;       Returns >=0 byte-count, or <0 error.
;;
;;   - stdout_puts(buf, len)
;;       Alias for stdout_write (kept for readability).
;;
;;   - stdout_println(buf, len)
;;       Writes bytes, then writes a single "\n".
;;
;;   - stdout_nl(), stdout_tab(), stdout_cr(), stdout_bs(), stdout_ff(), stdout_vt(), stdout_bell()
;;       Single-byte ASCII control characters.
;;
;; Notes:
;;   - String escapes are handled by `sirc` at compile time: "\n", "\t", "\r", "\\", "\xHH", etc.
;;   - Passing explicit lengths is intentional; SIR currently has no built-in string-length operator.
;;
;; Convenience helpers (not “golden”, may allocate):
;;   - stdout_putc/stderr_putc allocate 1 byte to write a single char.
;;   - stdout_print_i32/stdout_print_bool format values for debugging.

fn stdout_handle() -> i32
  return 1:i32
end

fn stderr_handle() -> i32
  return 2:i32
end

fn stdout_write(buf:ptr, len:i32) -> i32
  return zi_write(stdout_handle(), buf, len)
end

fn stderr_write(buf:ptr, len:i32) -> i32
  return zi_write(stderr_handle(), buf, len)
end

fn stdout_putc(ch:i8) -> i32
  let p: ptr = zi_alloc(1:i32)
  store.i8(p, ch)
  let w: i32 = stdout_write(p, 1:i32)
  let ignored_free: i32 = zi_free(p)
  return w
end

fn stderr_putc(ch:i8) -> i32
  let p: ptr = zi_alloc(1:i32)
  store.i8(p, ch)
  let w: i32 = stderr_write(p, 1:i32)
  let ignored_free: i32 = zi_free(p)
  return w
end

;; Basic control characters (ASCII)
fn stdout_nl() -> i32
  return stdout_putc(10:i8)
end

fn stdout_tab() -> i32
  return stdout_putc(9:i8)
end

fn stdout_cr() -> i32
  return stdout_putc(13:i8)
end

fn stdout_bell() -> i32
  return stdout_putc(7:i8)
end

fn stdout_bs() -> i32
  return stdout_putc(8:i8)
end

fn stdout_ff() -> i32
  return stdout_putc(12:i8)
end

fn stdout_vt() -> i32
  return stdout_putc(11:i8)
end

fn stdout_puts(buf:ptr, len:i32) -> i32
  return stdout_write(buf, len)
end

fn stdout_println(buf:ptr, len:i32) -> i32
  block entry
    let w: i32 = stdout_write(buf, len)
    let ok: bool = i32.cmp.sge(w, 0:i32)
    term.cbr cond:ok,
      then:nl,
      else:done args:[w]
  end

  block nl
    let newline: ptr = "\n"
    let w2: i32 = stdout_write(newline, 1:i32)
    term.ret value:w2
  end

  block done(w:i32)
    term.ret value:w
  end
end

;; Convert i32 to decimal bytes (full i32 range). Buffer must be at least 12 bytes.
fn i32_to_dec(v:i32, buffer:ptr) -> i32
  block entry
    let is_zero: bool = i32.cmp.eq(v, 0)
    term.cbr cond:is_zero,
      then:ret_zero,
      else:check_int_min
  end

  block ret_zero
    store.i8(ptr.offset(i8, buffer, 0), 48:i8)
    store.i8(ptr.offset(i8, buffer, 1), 0:i8)
    term.ret value:1:i32
  end

  block check_int_min
    let int_min: i32 = -2147483648:i32
    let is_int_min: bool = i32.cmp.eq(v, int_min)
    term.cbr cond:is_int_min,
      then:copy_int_min,
      else:setup
  end

  block copy_int_min
    term.br to copy_loop args:[0:i32]
  end

  block copy_loop(i:i32)
    let cont: bool = i32.cmp.slt(i, 11:i32)
    term.cbr cond:cont,
      then:copy_body args:[i],
      else:copy_done
  end

  block copy_body(i:i32)
    let s: ptr = "-2147483648"
    let c: i8 = load.i8(ptr.offset(i8, s, i))
    store.i8(ptr.offset(i8, buffer, i), c)
    let i2: i32 = i32.add(i, 1:i32)
    term.br to copy_loop args:[i2]
  end

  block copy_done
    store.i8(ptr.offset(i8, buffer, 11:i32), 0:i8)
    term.ret value:11:i32
  end

  block setup
    let is_negative: bool = i32.cmp.slt(v, 0:i32)
    let abs_value: i32 = select(i32, is_negative, i32.neg(v), v)

    let digits: ptr = zi_alloc(10:i32)
    term.br to digit_loop args:[abs_value, 0:i32, digits, is_negative]
  end

  block digit_loop(remaining:i32, digit_count:i32, digits:ptr, is_negative:bool)
    let cont: bool = i32.cmp.sgt(remaining, 0:i32)
    term.cbr cond:cont,
      then:digit_body args:[remaining, digit_count, digits, is_negative],
      else:write_sign args:[digit_count, digits, is_negative]
  end

  block digit_body(remaining:i32, digit_count:i32, digits:ptr, is_negative:bool)
    let digit: i32 = i32.rem.s.sat(remaining, 10:i32)
    let digit_char: i32 = i32.add(digit, 48:i32)
    store.i8(ptr.offset(i8, digits, digit_count), digit_char)
    let digit_count2: i32 = i32.add(digit_count, 1:i32)
    let remaining2: i32 = i32.div.s.sat(remaining, 10:i32)
    term.br to digit_loop args:[remaining2, digit_count2, digits, is_negative]
  end

  block write_sign(digit_count:i32, digits:ptr, is_negative:bool)
    let digit_idx: i32 = i32.sub(digit_count, 1:i32)
    term.cbr cond:is_negative,
      then:write_minus args:[digit_idx, digits],
      else:write_start args:[digit_idx, 0:i32, digits]
  end

  block write_minus(digit_idx:i32, digits:ptr)
    store.i8(ptr.offset(i8, buffer, 0:i32), 45:i8)
    term.br to write_start args:[digit_idx, 1:i32, digits]
  end

  block write_start(digit_idx:i32, pos:i32, digits:ptr)
    term.br to write_loop args:[digit_idx, pos, digits]
  end

  block write_loop(digit_idx:i32, pos:i32, digits:ptr)
    let cont: bool = i32.cmp.sge(digit_idx, 0:i32)
    term.cbr cond:cont,
      then:write_body args:[digit_idx, pos, digits],
      else:finish args:[pos, digits]
  end

  block write_body(digit_idx:i32, pos:i32, digits:ptr)
    let c: i8 = load.i8(ptr.offset(i8, digits, digit_idx))
    store.i8(ptr.offset(i8, buffer, pos), c)
    let pos2: i32 = i32.add(pos, 1:i32)
    let digit_idx2: i32 = i32.sub(digit_idx, 1:i32)
    term.br to write_loop args:[digit_idx2, pos2, digits]
  end

  block finish(pos:i32, digits:ptr)
    store.i8(ptr.offset(i8, buffer, pos), 0:i8)
    let ignored_free: i32 = zi_free(digits)
    term.ret value:pos
  end
end

fn stdout_print_i32(v:i32) -> i32
  let buf: ptr = zi_alloc(12:i32)
  let n: i32 = i32_to_dec(v, buf)
  let w: i32 = stdout_write(buf, n)
  let ignored_free: i32 = zi_free(buf)
  return w
end

fn stdout_print_bool(v:bool) -> i32
  let s: ptr = select(ptr, v, "true", "false")
  let n: i32 = select(i32, v, 4:i32, 5:i32)
  return stdout_write(s, n)
end
