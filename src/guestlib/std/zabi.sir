@mod zabi

@include "zcl1.sir"

;; Guest-side zABI helpers layered on the raw externs.

type zabi_zcl1_hdr = array(i8, 24)

fn zabi_bytes_eq(a:ptr, b:ptr, n:i32) -> bool
  block entry
    term.br to loop args:[0:i32, true]
  end

  block loop(i:i32, ok:bool)
    let i_lt: bool = i32.cmp.slt(i, n)
    let cont: bool = bool.and(ok, i_lt)
    term.cbr cond:cont,
      then:body args:[i],
      else:exit args:[ok]
  end

  block body(i:i32)
    let av: i8 = load.i8(ptr.offset(i8, a, i))
    let bv: i8 = load.i8(ptr.offset(i8, b, i))
    let av32: i32 = i32.zext.i8(av)
    let bv32: i32 = i32.zext.i8(bv)
    let ok2: bool = i32.cmp.eq(av32, bv32)
    let i2: i32 = i32.add(i, 1:i32)
    term.br to loop args:[i2, ok2]
  end

  block exit(ok:bool)
    term.ret value:ok
  end
end

fn zabi_ctl_caps_list(res_buf:ptr, res_cap:i32) -> i32
  ;; Build a ZCL1 CAPS_LIST request (op=1, rid=1, payload_len=0).
  let req_ptr: ptr = zi_alloc(24:i32)

  ;; Header bytes (24): magic + version/op + rid + status + reserved + payload_len.
  store.i8(ptr.offset(i8, req_ptr, 0:i64), 90:i8)   ;; 'Z'
  store.i8(ptr.offset(i8, req_ptr, 1:i64), 67:i8)   ;; 'C'
  store.i8(ptr.offset(i8, req_ptr, 2:i64), 76:i8)   ;; 'L'
  store.i8(ptr.offset(i8, req_ptr, 3:i64), 49:i8)   ;; '1'
  store.i8(ptr.offset(i8, req_ptr, 4:i64), 1:i8)    ;; version u16 = 1
  store.i8(ptr.offset(i8, req_ptr, 5:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 6:i64), 1:i8)    ;; op u16 = 1 (CAPS_LIST)
  store.i8(ptr.offset(i8, req_ptr, 7:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 8:i64), 1:i8)    ;; rid u32 = 1
  store.i8(ptr.offset(i8, req_ptr, 9:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 10:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 11:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 12:i64), 0:i8)   ;; status u32 = 0 (request)
  store.i8(ptr.offset(i8, req_ptr, 13:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 14:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 15:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 16:i64), 0:i8)   ;; reserved u32 = 0
  store.i8(ptr.offset(i8, req_ptr, 17:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 18:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 19:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 20:i64), 0:i8)   ;; payload_len u32 = 0
  store.i8(ptr.offset(i8, req_ptr, 21:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 22:i64), 0:i8)
  store.i8(ptr.offset(i8, req_ptr, 23:i64), 0:i8)

  return zi_ctl(req_ptr, 24:i32, res_buf, res_cap)
end

fn zabi_caps_list_status_ok(resp_ptr:ptr, resp_len:i32) -> bool
  let ok_hdr: bool = zcl1_is_hdr(resp_ptr, resp_len)
  let op: i32 = zcl1_read_op_u16(resp_ptr)
  let rid: i32 = zcl1_read_rid(resp_ptr)
  let status: i32 = zcl1_read_status(resp_ptr)
  let payload_len: i32 = zcl1_read_payload_len(resp_ptr)

  let ok_ids: bool = bool.and(i32.cmp.eq(op, 1:i32), i32.cmp.eq(rid, 1:i32))
  let ok_status: bool = i32.cmp.eq(status, 1:i32)
  let ok_len: bool = select(bool, ok_hdr, i32.cmp.sge(resp_len, i32.add(24:i32, payload_len)), false)

  return bool.and(ok_hdr, bool.and(ok_ids, bool.and(ok_status, ok_len)))
end

fn zabi_caps_list_has(resp_ptr:ptr, resp_len:i32, kind:ptr, kind_len:i32, name:ptr, name_len:i32) -> bool
  block entry
    let ok: bool = zabi_caps_list_status_ok(resp_ptr, resp_len)
    term.cbr cond:ok,
      then:parse_hdr,
      else:exit_false
  end

  block parse_hdr
    let payload_len: i32 = zcl1_read_payload_len(resp_ptr)
    let payload: ptr = ptr.offset(i8, resp_ptr, 24:i64)

    let has_hdr: bool = i32.cmp.sge(payload_len, 8:i32)
    term.cbr cond:has_hdr,
      then:parse_ver,
      else:exit_false
  end

  block parse_ver
    let payload_len: i32 = zcl1_read_payload_len(resp_ptr)
    let payload: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let ver: i32 = zcl1_read_u32le(payload)
    term.cbr cond:i32.cmp.eq(ver, 1:i32),
      then:loop_init,
      else:exit_false
  end

  block loop_init
    let payload: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let cap_count: i32 = zcl1_read_u32le(ptr.offset(i8, payload, 4:i64))
    term.br to loop args:[0:i32, 8:i32, false, cap_count]
  end

  block loop(i:i32, off:i32, found:bool, cap_count:i32)
    let i_lt: bool = i32.cmp.slt(i, cap_count)
    let not_found: bool = bool.not(found)
    let cont: bool = bool.and(not_found, i_lt)
    term.cbr cond:cont,
      then:check_klen args:[i, off, found, cap_count],
      else:exit_found args:[found]
  end

  block check_klen(i:i32, off:i32, found:bool, cap_count:i32)
    let payload_len: i32 = zcl1_read_payload_len(resp_ptr)
    let off4: i32 = i32.add(off, 4:i32)
    let ok: bool = i32.cmp.sle(off4, payload_len)
    term.cbr cond:ok,
      then:read_klen args:[i, off, found, cap_count],
      else:exit_false
  end

  block read_klen(i:i32, off:i32, found:bool, cap_count:i32)
    let payload: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let klen: i32 = zcl1_read_u32le(ptr.offset(i8, payload, off))
    let off2: i32 = i32.add(off, 4:i32)
    term.br to check_kind args:[i, off2, found, cap_count, klen]
  end

  block check_kind(i:i32, off:i32, found:bool, cap_count:i32, klen:i32)
    let payload_len: i32 = zcl1_read_payload_len(resp_ptr)
    let offk: i32 = i32.add(off, klen)
    let offk4: i32 = i32.add(offk, 4:i32)
    let ok: bool = i32.cmp.sle(offk4, payload_len)
    term.cbr cond:ok,
      then:read_kind args:[i, off, found, cap_count, klen],
      else:exit_false
  end

  block read_kind(i:i32, off:i32, found:bool, cap_count:i32, klen:i32)
    let payload: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let kind_ptr2: ptr = ptr.offset(i8, payload, off)
    let kind_match: bool = bool.and(i32.cmp.eq(klen, kind_len), zabi_bytes_eq(kind_ptr2, kind, klen))
    let off2: i32 = i32.add(off, klen)
    term.br to read_nlen args:[i, off2, found, cap_count, kind_match]
  end

  block read_nlen(i:i32, off:i32, found:bool, cap_count:i32, kind_match:bool)
    let payload_len: i32 = zcl1_read_payload_len(resp_ptr)
    let off4: i32 = i32.add(off, 4:i32)
    let ok: bool = i32.cmp.sle(off4, payload_len)
    term.cbr cond:ok,
      then:read_nlen2 args:[i, off, found, cap_count, kind_match],
      else:exit_false
  end

  block read_nlen2(i:i32, off:i32, found:bool, cap_count:i32, kind_match:bool)
    let payload: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let nlen: i32 = zcl1_read_u32le(ptr.offset(i8, payload, off))
    let off2: i32 = i32.add(off, 4:i32)
    term.br to check_name args:[i, off2, found, cap_count, kind_match, nlen]
  end

  block check_name(i:i32, off:i32, found:bool, cap_count:i32, kind_match:bool, nlen:i32)
    let payload_len: i32 = zcl1_read_payload_len(resp_ptr)
    let offn: i32 = i32.add(off, nlen)
    let offn4: i32 = i32.add(offn, 4:i32)
    let ok: bool = i32.cmp.sle(offn4, payload_len)
    term.cbr cond:ok,
      then:read_name args:[i, off, found, cap_count, kind_match, nlen],
      else:exit_false
  end

  block read_name(i:i32, off:i32, found:bool, cap_count:i32, kind_match:bool, nlen:i32)
    let payload: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let name_ptr2: ptr = ptr.offset(i8, payload, off)
    let name_match2: bool = bool.and(i32.cmp.eq(nlen, name_len), zabi_bytes_eq(name_ptr2, name, nlen))
    let off2: i32 = i32.add(off, nlen)
    term.br to skip_flags args:[i, off2, found, cap_count, kind_match, name_match2]
  end

  block skip_flags(i:i32, off:i32, found:bool, cap_count:i32, kind_match:bool, name_match2:bool)
    let payload_len: i32 = zcl1_read_payload_len(resp_ptr)
    let off4: i32 = i32.add(off, 4:i32)
    let ok: bool = i32.cmp.sle(off4, payload_len)
    term.cbr cond:ok,
      then:cont args:[i, off, found, cap_count, kind_match, name_match2],
      else:exit_false
  end

  block cont(i:i32, off:i32, found:bool, cap_count:i32, kind_match:bool, name_match2:bool)
    let found2: bool = bool.or(found, bool.and(kind_match, name_match2))
    let i2: i32 = i32.add(i, 1:i32)
    let off2: i32 = i32.add(off, 4:i32)
    term.br to loop args:[i2, off2, found2, cap_count]
  end

  block exit_false
    term.ret value:false
  end

  block exit_found(found:bool)
    term.ret value:found
  end
end
