@mod ctl

@include "zcl1.sir"
@include "../include/zabi_externs.sir"

;; Higher-level zi_ctl helpers (ZCL1 framed).

fn ctl_op_caps_list() -> i32
  return 1:i32
end

fn ctl_op_sem_argv_count() -> i32
  return 1000:i32
end

fn ctl_bytes_eq(a:ptr, b:ptr, n:i32) -> bool
  block entry
    term.br to loop args:[0:i32, true]
  end

  block loop(i:i32, ok:bool)
    let i_lt: bool = i32.cmp.slt(i, n)
    let cont: bool = bool.and(ok, i_lt)
    term.cbr cond:cont,
      then:body args:[i],
      else:exit args:[ok]
  end

  block body(i:i32)
    let av: i8 = load.i8(ptr.offset(i8, a, i))
    let bv: i8 = load.i8(ptr.offset(i8, b, i))
    let av32: i32 = i32.zext.i8(av)
    let bv32: i32 = i32.zext.i8(bv)
    let ok2: bool = i32.cmp.eq(av32, bv32)
    let i2: i32 = i32.add(i, 1:i32)
    term.br to loop args:[i2, ok2]
  end

  block exit(ok:bool)
    term.ret value:ok
  end
end

fn ctl_memcpy(dst:ptr, src:ptr, n:i32) -> i32
  block entry
    term.br to loop args:[0:i32]
  end

  block loop(i:i32)
    let cont: bool = i32.cmp.slt(i, n)
    term.cbr cond:cont,
      then:body args:[i],
      else:done
  end

  block body(i:i32)
    let v: i8 = load.i8(ptr.offset(i8, src, i))
    store.i8(ptr.offset(i8, dst, i), v)
    let i2: i32 = i32.add(i, 1:i32)
    term.br to loop args:[i2]
  end

  block done
    term.ret value:0:i32
  end
end

fn ctl_call(op_u16:i32, rid_u32:i32, payload:ptr, payload_len:i32, resp_ptr:ptr, resp_cap:i32) -> i32
  block entry
    let req_len: i32 = i32.add(zcl1_hdr_size(), payload_len)
    let req: ptr = zi_alloc(req_len)
    let ignored_hdr: i32 = zcl1_write_hdr(req, op_u16, rid_u32, 0:i32, payload_len)

    let has_payload: bool = i32.cmp.sgt(payload_len, 0:i32)
    term.cbr cond:has_payload,
      then:copy args:[req_len, req],
      else:do_call args:[req_len, req]
  end

  block copy(req_len:i32, req:ptr)
    let req_payload: ptr = ptr.offset(i8, req, 24:i64)
    let ignored_copy: i32 = ctl_memcpy(req_payload, payload, payload_len)
    term.br to do_call args:[req_len, req]
  end

  block do_call(req_len:i32, req:ptr)
    let rc: i32 = zi_ctl(req, req_len, resp_ptr, resp_cap)
    let ignored_free: i32 = zi_free(req)
    term.ret value:rc
  end
end

fn ctl_resp_ok(resp_ptr:ptr, resp_len:i32, want_op:i32, want_rid:i32) -> bool
  let ok_hdr: bool = zcl1_is_hdr(resp_ptr, resp_len)
  let op: i32 = zcl1_read_op_u16(resp_ptr)
  let rid: i32 = zcl1_read_rid(resp_ptr)
  let status: i32 = zcl1_read_status(resp_ptr)
  let payload_len: i32 = zcl1_read_payload_len(resp_ptr)

  let ok_ids: bool = bool.and(i32.cmp.eq(op, want_op), i32.cmp.eq(rid, want_rid))
  let ok_status: bool = i32.cmp.eq(status, 1:i32)
  let ok_len: bool = select(bool, ok_hdr, i32.cmp.sge(resp_len, i32.add(24:i32, payload_len)), false)
  return bool.and(ok_hdr, bool.and(ok_ids, bool.and(ok_status, ok_len)))
end

fn ctl_resp_err_trace_is(resp_ptr:ptr, resp_len:i32, want_op:i32, want_rid:i32, trace:ptr, trace_len:i32) -> bool
  block entry
    let ok_hdr: bool = zcl1_is_hdr(resp_ptr, resp_len)
    let op: i32 = zcl1_read_op_u16(resp_ptr)
    let rid: i32 = zcl1_read_rid(resp_ptr)
    let status: i32 = zcl1_read_status(resp_ptr)
    let payload_len: i32 = zcl1_read_payload_len(resp_ptr)

    let ok_ids: bool = bool.and(i32.cmp.eq(op, want_op), i32.cmp.eq(rid, want_rid))
    let is_err: bool = i32.cmp.eq(status, 0:i32)
    let ok_len: bool = select(bool, ok_hdr, i32.cmp.sge(resp_len, i32.add(24:i32, payload_len)), false)
    let ok: bool = bool.and(ok_hdr, bool.and(ok_ids, bool.and(is_err, ok_len)))
    term.cbr cond:ok,
      then:parse,
      else:ret_false
  end

  block parse
    let payload: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let plen: i32 = zcl1_read_payload_len(resp_ptr)
    let has_u32: bool = i32.cmp.sge(plen, 4:i32)
    term.cbr cond:has_u32,
      then:read_len,
      else:ret_false
  end

  block read_len
    let payload: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let plen: i32 = zcl1_read_payload_len(resp_ptr)
    let tlen: i32 = zcl1_read_u32le(payload)
    let off: i32 = i32.add(4:i32, tlen)
    let in_bounds: bool = i32.cmp.sle(off, plen)
    let len_ok: bool = i32.cmp.eq(tlen, trace_len)
    let ok: bool = bool.and(in_bounds, len_ok)
    term.cbr cond:ok,
      then:cmp,
      else:ret_false
  end

  block cmp
    let payload: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let tptr: ptr = ptr.offset(i8, payload, 4:i64)
    let ok: bool = ctl_bytes_eq(tptr, trace, trace_len)
    term.ret value:ok
  end

  block ret_false
    term.ret value:false
  end
end
