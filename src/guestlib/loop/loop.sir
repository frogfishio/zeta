@mod loop

@include "../include/zabi_externs.sir"
@include "../std/zcl1.sir"

;; Guest-side helpers for the golden capability `sys:loop@v1`.
;;
;; Shape:
;;  - Open with `zi_cap_open` using kind="sys", name="loop".
;;  - Interact by sending ZCL1-framed requests over the returned handle via `zi_write`.
;;  - Read ZCL1-framed responses from the same handle via `zi_read`.
;;
;; Hosted-only `sem` supports timers + POLL timer events.
;; zingcore25 builds additionally support WATCH/UNWATCH and readiness events.

fn loop_write_u64le(dst:ptr, v:i64) -> i32
  store.i64(dst, v) +align=1
  return 8:i32
end

fn loop_read_u64le(src:ptr) -> i64
  return load.i64(src) +align=1
end

fn loop_zi_e_again() -> i32
  ;; From zi_sysabi25.h
  return -6:i32
end

fn loop_op_watch() -> i32
  return 1:i32
end

fn loop_op_unwatch() -> i32
  return 2:i32
end

fn loop_op_timer_arm() -> i32
  return 3:i32
end

fn loop_op_timer_cancel() -> i32
  return 4:i32
end

fn loop_op_poll() -> i32
  return 5:i32
end

fn loop_open() -> i32
  ;; Open request layout (40 bytes), little-endian:
  ;;   u64 kind_ptr; u32 kind_len;
  ;;   u64 name_ptr; u32 name_len;
  ;;   u32 mode; u64 params_ptr; u32 params_len

  let kind: ptr = "sys"
  let name: ptr = "loop"

  let req: ptr = zi_alloc(40:i32)

  let kind_i64: i64 = ptr.to_i64(kind)
  let name_i64: i64 = ptr.to_i64(name)

  let _: i32 = loop_write_u64le(ptr.offset(i8, req, 0:i64), kind_i64)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, req, 8:i64), 3:i32)
  let _: i32 = loop_write_u64le(ptr.offset(i8, req, 12:i64), name_i64)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, req, 20:i64), 4:i32)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, req, 24:i64), 0:i32)
  let _: i32 = loop_write_u64le(ptr.offset(i8, req, 28:i64), 0:i64)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, req, 36:i64), 0:i32)

  let h: i32 = zi_cap_open(req)
  let ignored_free: i32 = zi_free(req)
  return h
end

fn loop_write_all(h:i32, buf:ptr, len:i32) -> i32
  block entry
    term.br to loop args:[0:i32]
  end

  block loop(off:i32)
    let done: bool = i32.cmp.sge(off, len)
    term.cbr cond:done,
      then:exit_ok,
      else:step args:[off]
  end

  block step(off:i32)
    let rem: i32 = i32.sub(len, off)
    let p: ptr = ptr.offset(i8, buf, off)
    let w: i32 = zi_write(h, p, rem)

    let is_again: bool = i32.cmp.eq(w, loop_zi_e_again())
    term.cbr cond:is_again,
      then:loop args:[off],
      else:check_w args:[off, w]
  end

  block check_w(off:i32, w:i32)
    let bad: bool = i32.cmp.sle(w, 0:i32)
    term.cbr cond:bad,
      then:exit_err,
      else:cont args:[off, w]
  end

  block cont(off:i32, w:i32)
    let off2: i32 = i32.add(off, w)
    term.br to loop args:[off2]
  end

  block exit_ok
    term.ret value:0:i32
  end

  block exit_err
    term.ret value:-1:i32
  end
end

fn loop_read_full_frame(h:i32, dst:ptr, dst_cap:i32) -> i32
  ;; Reads until a full ZCL1 frame is assembled in `dst`.
  ;;
  ;; `need` starts at 0 meaning: “header not yet parsed”. Once `got >= 24`, we
  ;; parse payload_len and set `need = 24 + payload_len`.
  block entry
    term.br to loop args:[0:i32, 0:i32]
  end

  block loop(got:i32, need:i32)
    let need_is_0: bool = i32.cmp.eq(need, 0:i32)
    term.cbr cond:need_is_0,
      then:need0 args:[got, need],
      else:needn args:[got, need]
  end

  block need0(got:i32, need:i32)
    let have_hdr: bool = i32.cmp.sge(got, 24:i32)
    term.cbr cond:have_hdr,
      then:set_need args:[got, need],
      else:step args:[got, need]
  end

  block needn(got:i32, need:i32)
    let done: bool = i32.cmp.sge(got, need)
    term.cbr cond:done,
      then:exit_ok args:[need],
      else:step args:[got, need]
  end

  block step(got:i32, need:i32)
    let rem: i32 = i32.sub(dst_cap, got)
    let p: ptr = ptr.offset(i8, dst, got)
    let n: i32 = zi_read(h, p, rem)

    let is_again: bool = i32.cmp.eq(n, loop_zi_e_again())
    term.cbr cond:is_again,
      then:loop args:[got, need],
      else:check_n args:[got, need, n]
  end

  block check_n(got:i32, need:i32, n:i32)
    let bad: bool = i32.cmp.sle(n, 0:i32)
    term.cbr cond:bad,
      then:exit_err,
      else:cont args:[got, need, n]
  end

  block cont(got:i32, need:i32, n:i32)
    let got2: i32 = i32.add(got, n)
    term.br to loop args:[got2, need]
  end

  block set_need(got:i32, need:i32)
    let pl: i32 = zcl1_read_payload_len(dst)
    let need2: i32 = i32.add(24:i32, pl)
    let fits: bool = i32.cmp.sle(need2, dst_cap)
    term.cbr cond:fits,
      then:loop args:[got, need2],
      else:exit_err
  end

  block exit_ok(n:i32)
    term.ret value:n
  end

  block exit_err
    term.ret value:-1:i32
  end
end

fn loop_resp_ok(resp_ptr:ptr, resp_len:i32, op:i32, rid:i32) -> bool
  let ok_hdr: bool = zcl1_is_hdr(resp_ptr, resp_len)
  let ok_op: bool = i32.cmp.eq(zcl1_read_op_u16(resp_ptr), op)
  let ok_rid: bool = i32.cmp.eq(zcl1_read_rid(resp_ptr), rid)
  let ok_status: bool = i32.cmp.eq(zcl1_read_status(resp_ptr), 1:i32)
  let pl: i32 = zcl1_read_payload_len(resp_ptr)
  let ok_len: bool = i32.cmp.sge(resp_len, i32.add(24:i32, pl))
  return bool.and(ok_hdr, bool.and(ok_op, bool.and(ok_rid, bool.and(ok_status, ok_len))))
end

fn loop_call(h:i32, op:i32, rid:i32, payload:ptr, payload_len:i32, resp_ptr:ptr, resp_cap:i32) -> i32
  block entry
    let fr_len: i32 = i32.add(24:i32, payload_len)
    let fr: ptr = zi_alloc(fr_len)
    let _: i32 = zcl1_write_hdr(fr, op, rid, 0:i32, payload_len)

    let has_pl: bool = i32.cmp.sgt(payload_len, 0:i32)
    term.cbr cond:has_pl,
      then:copy args:[fr, fr_len],
      else:write args:[fr, fr_len]
  end

  block copy(fr:ptr, fr_len:i32)
    let dst: ptr = ptr.offset(i8, fr, 24:i64)
    mem.copy(dst, payload, payload_len) +alignDst=1 +alignSrc=1 +overlap=disallow
    term.br to write args:[fr, fr_len]
  end

  block write(fr:ptr, fr_len:i32)
    let wrc: i32 = loop_write_all(h, fr, fr_len)
    let ignored_free: i32 = zi_free(fr)
    let ok: bool = i32.cmp.eq(wrc, 0:i32)
    term.cbr cond:ok,
      then:read,
      else:exit_err
  end

  block read
    let n: i32 = loop_read_full_frame(h, resp_ptr, resp_cap)
    term.ret value:n
  end

  block exit_err
    term.ret value:-1:i32
  end
end

fn loop_timer_arm(h:i32, rid:i32, timer_id:i32, due_ns:i32, interval_ns:i32, arm_flags:i32, resp_ptr:ptr, resp_cap:i32) -> i32
  let pl: ptr = zi_alloc(28:i32)
  let timer_id64: i64 = i64.zext.i32(timer_id)
  let due_ns64: i64 = i64.zext.i32(due_ns)
  let interval_ns64: i64 = i64.zext.i32(interval_ns)
  let _: i32 = loop_write_u64le(ptr.offset(i8, pl, 0:i64), timer_id64)
  let _: i32 = loop_write_u64le(ptr.offset(i8, pl, 8:i64), due_ns64)
  let _: i32 = loop_write_u64le(ptr.offset(i8, pl, 16:i64), interval_ns64)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, pl, 24:i64), arm_flags)

  let n: i32 = loop_call(h, loop_op_timer_arm(), rid, pl, 28:i32, resp_ptr, resp_cap)
  let ignored_free: i32 = zi_free(pl)
  return n
end

fn loop_poll(h:i32, rid:i32, max_events:i32, timeout_ms:i32, resp_ptr:ptr, resp_cap:i32) -> i32
  let pl: ptr = zi_alloc(8:i32)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, pl, 0:i64), max_events)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, pl, 4:i64), timeout_ms)

  let n: i32 = loop_call(h, loop_op_poll(), rid, pl, 8:i32, resp_ptr, resp_cap)
  let ignored_free: i32 = zi_free(pl)
  return n
end

fn loop_poll_has_timer(resp_ptr:ptr, resp_len:i32, rid:i32, timer_id:i32) -> bool
  block entry
    let ok: bool = loop_resp_ok(resp_ptr, resp_len, loop_op_poll(), rid)
    term.cbr cond:ok,
      then:parse_hdr,
      else:exit_false
  end

  block parse_hdr
    let pl_len: i32 = zcl1_read_payload_len(resp_ptr)
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let has_hdr: bool = i32.cmp.sge(pl_len, 16:i32)
    term.cbr cond:has_hdr,
      then:parse_ver,
      else:exit_false
  end

  block parse_ver
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let ver: i32 = zcl1_read_u32le(ptr.offset(i8, pl, 0:i64))
    term.cbr cond:i32.cmp.eq(ver, 1:i32),
      then:loop_init,
      else:exit_false
  end

  block loop_init
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let ev_count: i32 = zcl1_read_u32le(ptr.offset(i8, pl, 8:i64))
    term.br to loop args:[0:i32, ev_count, false]
  end

  block loop(i:i32, ev_count:i32, found:bool)
    let i_lt: bool = i32.cmp.slt(i, ev_count)
    let not_found: bool = bool.not(found)
    let cont: bool = bool.and(i_lt, not_found)
    term.cbr cond:cont,
      then:check_one args:[i, ev_count, found],
      else:exit_found args:[found]
  end

  block check_one(i:i32, ev_count:i32, found:bool)
    let pl_len: i32 = zcl1_read_payload_len(resp_ptr)
    let base: i32 = i32.add(16:i32, i32.mul(i, 32:i32))
    let off_end: i32 = i32.add(base, 32:i32)
    let ok: bool = i32.cmp.sle(off_end, pl_len)
    term.cbr cond:ok,
      then:read_one args:[i, ev_count, found, base],
      else:exit_false
  end

  block read_one(i:i32, ev_count:i32, found:bool, base:i32)
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let e: ptr = ptr.offset(i8, pl, base)

    let kind: i32 = zcl1_read_u32le(ptr.offset(i8, e, 0:i64))
    let h: i32 = zcl1_read_u32le(ptr.offset(i8, e, 8:i64))
    let id_lo: i32 = zcl1_read_u32le(ptr.offset(i8, e, 16:i64))
    let id_hi: i32 = zcl1_read_u32le(ptr.offset(i8, e, 20:i64))

    let is_timer: bool = i32.cmp.eq(kind, 2:i32)
    let h_is_zero: bool = i32.cmp.eq(h, 0:i32)
    let id_hi_ok: bool = i32.cmp.eq(id_hi, 0:i32)
    let id_lo_ok: bool = i32.cmp.eq(id_lo, timer_id)
    let id_ok: bool = bool.and(id_hi_ok, id_lo_ok)
    let found2: bool = bool.or(found, bool.and(is_timer, bool.and(h_is_zero, id_ok)))

    let i2: i32 = i32.add(i, 1:i32)
    term.br to loop args:[i2, ev_count, found2]
  end

  block exit_false
    term.ret value:false
  end

  block exit_found(found:bool)
    term.ret value:found
  end
end

fn loop_sleep_ms(ms:i32) -> i32
  ;; MVP "sleep" implemented via sys/loop timers.
  block entry
    let h: i32 = loop_open()
    let resp: ptr = zi_alloc(512:i32)
    let ok_open: bool = i32.cmp.sge(h, 3:i32)
    term.cbr cond:ok_open,
      then:arm args:[h, resp],
      else:fail_open args:[resp]
  end

  block arm(h:i32, resp:ptr)
    let due_ns: i32 = i32.mul(ms, 1000000:i32)
    let timer_id: i32 = 1:i32
    let n1: i32 = loop_timer_arm(h, 1:i32, timer_id, due_ns, 0:i32, 1:i32, resp, 512:i32)
    let ok1: bool = loop_resp_ok(resp, n1, loop_op_timer_arm(), 1:i32)
    term.cbr cond:ok1,
      then:poll args:[h, resp, timer_id],
      else:fail_arm args:[h, resp]
  end

  block poll(h:i32, resp:ptr, timer_id:i32)
    let timeout: i32 = i32.add(ms, 100:i32)
    let n2: i32 = loop_poll(h, 2:i32, 4:i32, timeout, resp, 512:i32)
    let ok2: bool = loop_poll_has_timer(resp, n2, 2:i32, timer_id)
    term.cbr cond:ok2,
      then:ok args:[h, resp],
      else:fail_poll args:[h, resp]
  end

  block ok(h:i32, resp:ptr)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:0:i32
  end

  block fail_open(resp:ptr)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:1:i32
  end

  block fail_arm(h:i32, resp:ptr)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:2:i32
  end

  block fail_poll(h:i32, resp:ptr)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:3:i32
  end
end
