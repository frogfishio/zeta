@mod loop

@include "../include/zabi_externs.sir"
@include "../std/zcl1.sir"

;; Guest-side helpers for the golden capability `sys:loop@v1`.
;;
;; Shape:
;;  - Open with `zi_cap_open` using kind="sys", name="loop".
;;  - Interact by sending ZCL1-framed requests over the returned handle via `zi_write`.
;;  - Read ZCL1-framed responses from the same handle via `zi_read`.
;;
;; Hosted-only `sem` supports timers + POLL timer events.
;; zingcore25 builds additionally support WATCH/UNWATCH and readiness events.

fn loop_write_u64le(dst:ptr, v:i64) -> i32
  store.i64(dst, v) +align=1
  return 8:i32
end

fn loop_read_u64le(src:ptr) -> i64
  return load.i64(src) +align=1
end

fn loop_bytes_eq(a:ptr, b:ptr, n:i32) -> bool
  block entry
    term.br to loop args:[0:i32, true]
  end

  block loop(i:i32, ok:bool)
    let i_lt: bool = i32.cmp.slt(i, n)
    let cont: bool = bool.and(ok, i_lt)
    term.cbr cond:cont,
      then:body args:[i],
      else:exit args:[ok]
  end

  block body(i:i32)
    let av: i8 = load.i8(ptr.offset(i8, a, i))
    let bv: i8 = load.i8(ptr.offset(i8, b, i))
    let av32: i32 = i32.zext.i8(av)
    let bv32: i32 = i32.zext.i8(bv)
    let ok2: bool = i32.cmp.eq(av32, bv32)
    let i2: i32 = i32.add(i, 1:i32)
    term.br to loop args:[i2, ok2]
  end

  block exit(ok:bool)
    term.ret value:ok
  end
end

fn loop_zi_e_again() -> i32
  ;; From zi_sysabi25.h
  return -6:i32
end

fn loop_op_watch() -> i32
  return 1:i32
end

fn loop_op_unwatch() -> i32
  return 2:i32
end

fn loop_op_timer_arm() -> i32
  return 3:i32
end

fn loop_op_timer_cancel() -> i32
  return 4:i32
end

fn loop_op_poll() -> i32
  return 5:i32
end

fn loop_watch_ev_readable() -> i32
  return 1:i32
end

fn loop_watch_ev_writable() -> i32
  return 2:i32
end

fn loop_watch_ev_hup() -> i32
  return 4:i32
end

fn loop_watch_ev_error() -> i32
  return 8:i32
end

fn loop_open() -> i32
  ;; Open request layout (40 bytes), little-endian:
  ;;   u64 kind_ptr; u32 kind_len;
  ;;   u64 name_ptr; u32 name_len;
  ;;   u32 mode; u64 params_ptr; u32 params_len

  let kind: ptr = "sys"
  let name: ptr = "loop"

  let req: ptr = zi_alloc(40:i32)

  let kind_i64: i64 = ptr.to_i64(kind)
  let name_i64: i64 = ptr.to_i64(name)

  let _: i32 = loop_write_u64le(ptr.offset(i8, req, 0:i64), kind_i64)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, req, 8:i64), 3:i32)
  let _: i32 = loop_write_u64le(ptr.offset(i8, req, 12:i64), name_i64)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, req, 20:i64), 4:i32)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, req, 24:i64), 0:i32)
  let _: i32 = loop_write_u64le(ptr.offset(i8, req, 28:i64), 0:i64)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, req, 36:i64), 0:i32)

  let h: i32 = zi_cap_open(req)
  let ignored_free: i32 = zi_free(req)
  return h
end

fn loop_write_all(h:i32, buf:ptr, len:i32) -> i32
  block entry
    term.br to loop args:[0:i32]
  end

  block loop(off:i32)
    let done: bool = i32.cmp.sge(off, len)
    term.cbr cond:done,
      then:exit_ok,
      else:step args:[off]
  end

  block step(off:i32)
    let rem: i32 = i32.sub(len, off)
    let p: ptr = ptr.offset(i8, buf, off)
    let w: i32 = zi_write(h, p, rem)

    let is_again: bool = i32.cmp.eq(w, loop_zi_e_again())
    term.cbr cond:is_again,
      then:loop args:[off],
      else:check_w args:[off, w]
  end

  block check_w(off:i32, w:i32)
    let bad: bool = i32.cmp.sle(w, 0:i32)
    term.cbr cond:bad,
      then:exit_err,
      else:cont args:[off, w]
  end

  block cont(off:i32, w:i32)
    let off2: i32 = i32.add(off, w)
    term.br to loop args:[off2]
  end

  block exit_ok
    term.ret value:0:i32
  end

  block exit_err
    term.ret value:-1:i32
  end
end

fn loop_read_full_frame(h:i32, dst:ptr, dst_cap:i32) -> i32
  ;; Reads until a full ZCL1 frame is assembled in `dst`.
  ;;
  ;; `need` starts at 0 meaning: “header not yet parsed”. Once `got >= 24`, we
  ;; parse payload_len and set `need = 24 + payload_len`.
  block entry
    term.br to loop args:[0:i32, 0:i32]
  end

  block loop(got:i32, need:i32)
    let need_is_0: bool = i32.cmp.eq(need, 0:i32)
    term.cbr cond:need_is_0,
      then:need0 args:[got, need],
      else:needn args:[got, need]
  end

  block need0(got:i32, need:i32)
    let have_hdr: bool = i32.cmp.sge(got, 24:i32)
    term.cbr cond:have_hdr,
      then:set_need args:[got, need],
      else:step args:[got, need]
  end

  block needn(got:i32, need:i32)
    let done: bool = i32.cmp.sge(got, need)
    term.cbr cond:done,
      then:exit_ok args:[need],
      else:step args:[got, need]
  end

  block step(got:i32, need:i32)
    let rem: i32 = i32.sub(dst_cap, got)
    let p: ptr = ptr.offset(i8, dst, got)
    let n: i32 = zi_read(h, p, rem)

    let is_again: bool = i32.cmp.eq(n, loop_zi_e_again())
    term.cbr cond:is_again,
      then:loop args:[got, need],
      else:check_n args:[got, need, n]
  end

  block check_n(got:i32, need:i32, n:i32)
    let bad: bool = i32.cmp.sle(n, 0:i32)
    term.cbr cond:bad,
      then:exit_err,
      else:cont args:[got, need, n]
  end

  block cont(got:i32, need:i32, n:i32)
    let got2: i32 = i32.add(got, n)
    term.br to loop args:[got2, need]
  end

  block set_need(got:i32, need:i32)
    let pl: i32 = zcl1_read_payload_len(dst)
    let need2: i32 = i32.add(24:i32, pl)
    let fits: bool = i32.cmp.sle(need2, dst_cap)
    term.cbr cond:fits,
      then:loop args:[got, need2],
      else:exit_err
  end

  block exit_ok(n:i32)
    term.ret value:n
  end

  block exit_err
    term.ret value:-1:i32
  end
end

fn loop_resp_ok(resp_ptr:ptr, resp_len:i32, op:i32, rid:i32) -> bool
  let ok_hdr: bool = zcl1_is_hdr(resp_ptr, resp_len)
  let ok_op: bool = i32.cmp.eq(zcl1_read_op_u16(resp_ptr), op)
  let ok_rid: bool = i32.cmp.eq(zcl1_read_rid(resp_ptr), rid)
  let ok_status: bool = i32.cmp.eq(zcl1_read_status(resp_ptr), 1:i32)
  let pl: i32 = zcl1_read_payload_len(resp_ptr)
  let ok_len: bool = i32.cmp.sge(resp_len, i32.add(24:i32, pl))
  return bool.and(ok_hdr, bool.and(ok_op, bool.and(ok_rid, bool.and(ok_status, ok_len))))
end

fn loop_resp_hdr_matches(resp_ptr:ptr, resp_len:i32, op:i32, rid:i32) -> bool
  let ok_hdr: bool = zcl1_is_hdr(resp_ptr, resp_len)
  let ok_op: bool = i32.cmp.eq(zcl1_read_op_u16(resp_ptr), op)
  let ok_rid: bool = i32.cmp.eq(zcl1_read_rid(resp_ptr), rid)
  let pl: i32 = zcl1_read_payload_len(resp_ptr)
  let ok_len: bool = i32.cmp.sge(resp_len, i32.add(24:i32, pl))
  return bool.and(ok_hdr, bool.and(ok_op, bool.and(ok_rid, ok_len)))
end

fn loop_resp_err_trace_is(resp_ptr:ptr, resp_len:i32, op:i32, rid:i32, want_trace:ptr, want_trace_len:i32) -> bool
  ;; ZCL1 error payload layout:
  ;;   u32 trace_len; trace_bytes...
  ;;   u32 msg_len;   msg_bytes...
  ;;   u32 detail_len; detail_bytes...
  ;; We only need the first field for sem's hosted nosys detection.
  block entry
    let hdr_ok: bool = loop_resp_hdr_matches(resp_ptr, resp_len, op, rid)
    term.cbr cond:hdr_ok,
      then:check_status,
      else:exit_false
  end

  block check_status
    let is_err: bool = i32.cmp.eq(zcl1_read_status(resp_ptr), 0:i32)
    term.cbr cond:is_err,
      then:parse_pl,
      else:exit_false
  end

  block parse_pl
    let pl_len: i32 = zcl1_read_payload_len(resp_ptr)
    let has_u32: bool = i32.cmp.sge(pl_len, 4:i32)
    term.cbr cond:has_u32,
      then:read_len,
      else:exit_false
  end

  block read_len
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let n: i32 = zcl1_read_u32le(pl)
    let off_end: i32 = i32.add(4:i32, n)
    let pl_len: i32 = zcl1_read_payload_len(resp_ptr)
    let in_bounds: bool = i32.cmp.sle(off_end, pl_len)
    term.cbr cond:in_bounds,
      then:cmp,
      else:exit_false
  end

  block cmp
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let n: i32 = zcl1_read_u32le(pl)
    let same_len: bool = i32.cmp.eq(n, want_trace_len)
    let trace_ptr2: ptr = ptr.offset(i8, pl, 4:i64)
    let same: bool = bool.and(same_len, loop_bytes_eq(trace_ptr2, want_trace, n))
    term.ret value:same
  end

  block exit_false
    term.ret value:false
  end
end

fn loop_call(h:i32, op:i32, rid:i32, payload:ptr, payload_len:i32, resp_ptr:ptr, resp_cap:i32) -> i32
  block entry
    let fr_len: i32 = i32.add(24:i32, payload_len)
    let fr: ptr = zi_alloc(fr_len)
    let _: i32 = zcl1_write_hdr(fr, op, rid, 0:i32, payload_len)

    let has_pl: bool = i32.cmp.sgt(payload_len, 0:i32)
    term.cbr cond:has_pl,
      then:copy args:[fr, fr_len],
      else:write args:[fr, fr_len]
  end

  block copy(fr:ptr, fr_len:i32)
    let dst: ptr = ptr.offset(i8, fr, 24:i64)
    mem.copy(dst, payload, payload_len) +alignDst=1 +alignSrc=1 +overlap=disallow
    term.br to write args:[fr, fr_len]
  end

  block write(fr:ptr, fr_len:i32)
    let wrc: i32 = loop_write_all(h, fr, fr_len)
    let ignored_free: i32 = zi_free(fr)
    let ok: bool = i32.cmp.eq(wrc, 0:i32)
    term.cbr cond:ok,
      then:read,
      else:exit_err
  end

  block read
    let n: i32 = loop_read_full_frame(h, resp_ptr, resp_cap)
    term.ret value:n
  end

  block exit_err
    term.ret value:-1:i32
  end
end

fn loop_timer_arm(h:i32, rid:i32, timer_id:i32, due_ns:i32, interval_ns:i32, arm_flags:i32, resp_ptr:ptr, resp_cap:i32) -> i32
  let pl: ptr = zi_alloc(28:i32)
  let timer_id64: i64 = i64.zext.i32(timer_id)
  let due_ns64: i64 = i64.zext.i32(due_ns)
  let interval_ns64: i64 = i64.zext.i32(interval_ns)
  let _: i32 = loop_write_u64le(ptr.offset(i8, pl, 0:i64), timer_id64)
  let _: i32 = loop_write_u64le(ptr.offset(i8, pl, 8:i64), due_ns64)
  let _: i32 = loop_write_u64le(ptr.offset(i8, pl, 16:i64), interval_ns64)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, pl, 24:i64), arm_flags)

  let n: i32 = loop_call(h, loop_op_timer_arm(), rid, pl, 28:i32, resp_ptr, resp_cap)
  let ignored_free: i32 = zi_free(pl)
  return n
end

fn loop_poll(h:i32, rid:i32, max_events:i32, timeout_ms:i32, resp_ptr:ptr, resp_cap:i32) -> i32
  let pl: ptr = zi_alloc(8:i32)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, pl, 0:i64), max_events)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, pl, 4:i64), timeout_ms)

  let n: i32 = loop_call(h, loop_op_poll(), rid, pl, 8:i32, resp_ptr, resp_cap)
  let ignored_free: i32 = zi_free(pl)
  return n
end

fn loop_watch(h:i32, rid:i32, handle:i32, events:i32, watch_id:i64, watch_flags:i32, resp_ptr:ptr, resp_cap:i32) -> i32
  ;; WATCH payload (20 bytes): u32 handle, u32 events, u64 watch_id, u32 flags
  let pl: ptr = zi_alloc(20:i32)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, pl, 0:i64), handle)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, pl, 4:i64), events)
  let _: i32 = loop_write_u64le(ptr.offset(i8, pl, 8:i64), watch_id)
  let _: i32 = zcl1_write_u32le(ptr.offset(i8, pl, 16:i64), watch_flags)

  let n: i32 = loop_call(h, loop_op_watch(), rid, pl, 20:i32, resp_ptr, resp_cap)
  let ignored_free: i32 = zi_free(pl)
  return n
end

fn loop_unwatch(h:i32, rid:i32, watch_id:i64, resp_ptr:ptr, resp_cap:i32) -> i32
  ;; UNWATCH payload (8 bytes): u64 watch_id
  let pl: ptr = zi_alloc(8:i32)
  let _: i32 = loop_write_u64le(pl, watch_id)
  let n: i32 = loop_call(h, loop_op_unwatch(), rid, pl, 8:i32, resp_ptr, resp_cap)
  let ignored_free: i32 = zi_free(pl)
  return n
end

fn loop_poll_event_count(resp_ptr:ptr, resp_len:i32, rid:i32) -> i32
  ;; Returns event_count for an OK POLL response, else -1.
  block entry
    let ok: bool = loop_resp_ok(resp_ptr, resp_len, loop_op_poll(), rid)
    term.cbr cond:ok,
      then:parse,
      else:bad
  end

  block parse
    let pl_len: i32 = zcl1_read_payload_len(resp_ptr)
    let has_hdr: bool = i32.cmp.sge(pl_len, 16:i32)
    term.cbr cond:has_hdr,
      then:read,
      else:bad
  end

  block read
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let ver: i32 = zcl1_read_u32le(ptr.offset(i8, pl, 0:i64))
    let ver_ok: bool = i32.cmp.eq(ver, 1:i32)
    term.cbr cond:ver_ok,
      then:got_count,
      else:bad
  end

  block got_count
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let c: i32 = zcl1_read_u32le(ptr.offset(i8, pl, 8:i64))
    term.ret value:c
  end

  block bad
    term.ret value:-1:i32
  end
end

fn loop_poll_has_timer(resp_ptr:ptr, resp_len:i32, rid:i32, timer_id:i32) -> bool
  block entry
    let ok: bool = loop_resp_ok(resp_ptr, resp_len, loop_op_poll(), rid)
    term.cbr cond:ok,
      then:parse_hdr,
      else:exit_false
  end

  block parse_hdr
    let pl_len: i32 = zcl1_read_payload_len(resp_ptr)
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let has_hdr: bool = i32.cmp.sge(pl_len, 16:i32)
    term.cbr cond:has_hdr,
      then:parse_ver,
      else:exit_false
  end

  block parse_ver
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let ver: i32 = zcl1_read_u32le(ptr.offset(i8, pl, 0:i64))
    term.cbr cond:i32.cmp.eq(ver, 1:i32),
      then:loop_init,
      else:exit_false
  end

  block loop_init
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let ev_count: i32 = zcl1_read_u32le(ptr.offset(i8, pl, 8:i64))
    term.br to loop args:[0:i32, ev_count, false]
  end

  block loop(i:i32, ev_count:i32, found:bool)
    let i_lt: bool = i32.cmp.slt(i, ev_count)
    let not_found: bool = bool.not(found)
    let cont: bool = bool.and(i_lt, not_found)
    term.cbr cond:cont,
      then:check_one args:[i, ev_count, found],
      else:exit_found args:[found]
  end

  block check_one(i:i32, ev_count:i32, found:bool)
    let pl_len: i32 = zcl1_read_payload_len(resp_ptr)
    let base: i32 = i32.add(16:i32, i32.mul(i, 32:i32))
    let off_end: i32 = i32.add(base, 32:i32)
    let ok: bool = i32.cmp.sle(off_end, pl_len)
    term.cbr cond:ok,
      then:read_one args:[i, ev_count, found, base],
      else:exit_false
  end

  block read_one(i:i32, ev_count:i32, found:bool, base:i32)
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let e: ptr = ptr.offset(i8, pl, base)

    let kind: i32 = zcl1_read_u32le(ptr.offset(i8, e, 0:i64))
    let h: i32 = zcl1_read_u32le(ptr.offset(i8, e, 8:i64))
    let id_lo: i32 = zcl1_read_u32le(ptr.offset(i8, e, 16:i64))
    let id_hi: i32 = zcl1_read_u32le(ptr.offset(i8, e, 20:i64))

    let is_timer: bool = i32.cmp.eq(kind, 2:i32)
    let h_is_zero: bool = i32.cmp.eq(h, 0:i32)
    let id_hi_ok: bool = i32.cmp.eq(id_hi, 0:i32)
    let id_lo_ok: bool = i32.cmp.eq(id_lo, timer_id)
    let id_ok: bool = bool.and(id_hi_ok, id_lo_ok)
    let found2: bool = bool.or(found, bool.and(is_timer, bool.and(h_is_zero, id_ok)))

    let i2: i32 = i32.add(i, 1:i32)
    term.br to loop args:[i2, ev_count, found2]
  end

  block exit_false
    term.ret value:false
  end

  block exit_found(found:bool)
    term.ret value:found
  end
end

fn loop_ev_ready() -> i32
  ;; ZI_SYS_LOOP_EV_READY
  return 1:i32
end

fn loop_ev_timer() -> i32
  ;; ZI_SYS_LOOP_EV_TIMER
  return 2:i32
end

fn loop_poll_has_ready(resp_ptr:ptr, resp_len:i32, rid:i32, handle:i32, watch_id:i64, want_events:i32) -> bool
  ;; Returns true iff an OK POLL response contains a READY event for (handle, watch_id)
  ;; with at least one bit from want_events (or any if want_events==0).
  block entry
    let ok: bool = loop_resp_ok(resp_ptr, resp_len, loop_op_poll(), rid)
    term.cbr cond:ok,
      then:parse_hdr,
      else:exit_false
  end

  block parse_hdr
    let pl_len: i32 = zcl1_read_payload_len(resp_ptr)
    let has_hdr: bool = i32.cmp.sge(pl_len, 16:i32)
    term.cbr cond:has_hdr,
      then:parse_ver,
      else:exit_false
  end

  block parse_ver
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let ver: i32 = zcl1_read_u32le(ptr.offset(i8, pl, 0:i64))
    term.cbr cond:i32.cmp.eq(ver, 1:i32),
      then:loop_init,
      else:exit_false
  end

  block loop_init
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let ev_count: i32 = zcl1_read_u32le(ptr.offset(i8, pl, 8:i64))
    term.br to loop args:[0:i32, ev_count, false]
  end

  block loop(i:i32, ev_count:i32, found:bool)
    let i_lt: bool = i32.cmp.slt(i, ev_count)
    let not_found: bool = bool.not(found)
    let cont: bool = bool.and(i_lt, not_found)
    term.cbr cond:cont,
      then:check_one args:[i, ev_count, found],
      else:exit_found args:[found]
  end

  block check_one(i:i32, ev_count:i32, found:bool)
    let pl_len: i32 = zcl1_read_payload_len(resp_ptr)
    let base: i32 = i32.add(16:i32, i32.mul(i, 32:i32))
    let off_end: i32 = i32.add(base, 32:i32)
    let ok: bool = i32.cmp.sle(off_end, pl_len)
    term.cbr cond:ok,
      then:read_one args:[i, ev_count, found, base],
      else:exit_false
  end

  block read_one(i:i32, ev_count:i32, found:bool, base:i32)
    let pl: ptr = ptr.offset(i8, resp_ptr, 24:i64)
    let e: ptr = ptr.offset(i8, pl, base)

    let kind: i32 = zcl1_read_u32le(ptr.offset(i8, e, 0:i64))
    let ev: i32 = zcl1_read_u32le(ptr.offset(i8, e, 4:i64))
    let h: i32 = zcl1_read_u32le(ptr.offset(i8, e, 8:i64))
    let id_lo: i32 = zcl1_read_u32le(ptr.offset(i8, e, 16:i64))
    let id_hi: i32 = zcl1_read_u32le(ptr.offset(i8, e, 20:i64))

    ;; Split watch_id into low/high u32 via a tiny stack buffer.
    let tmp: ptr = alloca.i64()
    store.i64(tmp, watch_id)
    let want_lo: i32 = zcl1_read_u32le(tmp)
    let want_hi: i32 = zcl1_read_u32le(ptr.offset(i8, tmp, 4:i64))

    let is_ready: bool = i32.cmp.eq(kind, loop_ev_ready())
    let h_ok: bool = i32.cmp.eq(h, handle)
    let id_ok: bool = bool.and(i32.cmp.eq(id_lo, want_lo), i32.cmp.eq(id_hi, want_hi))

    let any_ev: bool = i32.cmp.eq(want_events, 0:i32)
    let masked: i32 = i32.and(ev, want_events)
    let ev_ok: bool = bool.or(any_ev, i32.cmp.ne(masked, 0:i32))

    let found2: bool = bool.or(found, bool.and(is_ready, bool.and(h_ok, bool.and(id_ok, ev_ok))))

    let i2: i32 = i32.add(i, 1:i32)
    term.br to loop args:[i2, ev_count, found2]
  end

  block exit_false
    term.ret value:false
  end

  block exit_found(found:bool)
    term.ret value:found
  end
end

fn loop_wait_rc_ready() -> i32
  return 0:i32
end

fn loop_wait_rc_timeout() -> i32
  return 1:i32
end

fn loop_wait_rc_nosys() -> i32
  ;; Hosted `sem` sys/loop returns ZCL1 error trace "sem.sys_loop.nosys".
  return 2:i32
end

fn loop_wait_rc_watch_failed() -> i32
  return 3:i32
end

fn loop_wait_rc_poll_failed() -> i32
  return 4:i32
end

fn loop_wait_rc_open_failed() -> i32
  return 5:i32
end

fn loop_wait_events(handle:i32, events:i32, timeout_ms:i32) -> i32
  ;; Convenience: open sys/loop, WATCH, single POLL, then UNWATCH.
  ;; Never hangs on hosted `sem`: WATCH nosys returns `loop_wait_rc_nosys()`.
  block entry
    let h: i32 = loop_open()
    let resp: ptr = zi_alloc(1024:i32)
    let ok_open: bool = i32.cmp.sge(h, 3:i32)
    term.cbr cond:ok_open,
      then:watch args:[h, resp],
      else:fail_open args:[resp]
  end

  block watch(h:i32, resp:ptr)
    let watch_id: i64 = 1:i64
    let n1: i32 = loop_watch(h, 1:i32, handle, events, watch_id, 0:i32, resp, 1024:i32)
    let ok1: bool = loop_resp_ok(resp, n1, loop_op_watch(), 1:i32)
    term.cbr cond:ok1,
      then:poll args:[h, resp, watch_id],
      else:watch_err args:[h, resp, n1]
  end

  block watch_err(h:i32, resp:ptr, n1:i32)
    let nosys_trace: ptr = "sem.sys_loop.nosys"
    let is_nosys: bool = loop_resp_err_trace_is(resp, n1, loop_op_watch(), 1:i32, nosys_trace, 18:i32)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:select(i32, is_nosys, loop_wait_rc_nosys(), loop_wait_rc_watch_failed())
  end

  block poll(h:i32, resp:ptr, watch_id:i64)
    let n2: i32 = loop_poll(h, 2:i32, 16:i32, timeout_ms, resp, 1024:i32)
    let ok2: bool = loop_resp_ok(resp, n2, loop_op_poll(), 2:i32)
    term.cbr cond:ok2,
      then:check_ready args:[h, resp, watch_id, n2],
      else:poll_err args:[h, resp, watch_id]
  end

  block poll_err(h:i32, resp:ptr, watch_id:i64)
    let ignored_unwatch: i32 = loop_unwatch(h, 3:i32, watch_id, resp, 1024:i32)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:loop_wait_rc_poll_failed()
  end

  block check_ready(h:i32, resp:ptr, watch_id:i64, n2:i32)
    let ok_ready: bool = loop_poll_has_ready(resp, n2, 2:i32, handle, watch_id, events)
    let ignored_unwatch: i32 = loop_unwatch(h, 3:i32, watch_id, resp, 1024:i32)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:select(i32, ok_ready, loop_wait_rc_ready(), loop_wait_rc_timeout())
  end

  block fail_open(resp:ptr)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:loop_wait_rc_open_failed()
  end
end

fn loop_wait_readable(handle:i32, timeout_ms:i32) -> i32
  return loop_wait_events(handle, loop_watch_ev_readable(), timeout_ms)
end

fn loop_wait_writable(handle:i32, timeout_ms:i32) -> i32
  return loop_wait_events(handle, loop_watch_ev_writable(), timeout_ms)
end

fn loop_i32_min(a:i32, b:i32) -> i32
  let a_le_b: bool = i32.cmp.sle(a, b)
  return select(i32, a_le_b, a, b)
end

fn loop_wait_events_until(handle:i32, events:i32, timeout_ms:i32, poll_step_ms:i32) -> i32
  ;; Like `loop_wait_events`, but keeps polling until ready/timeout.
  ;;
  ;; Notes:
  ;; - If timeout_ms == -1, uses the sys/loop “infinite” timeout (0xFFFFFFFF).
  ;; - For finite timeouts, uses bounded poll slices of up to poll_step_ms.
  block entry
    let h: i32 = loop_open()
    let resp: ptr = zi_alloc(1024:i32)
    let ok_open: bool = i32.cmp.sge(h, 3:i32)
    term.cbr cond:ok_open,
      then:watch args:[h, resp],
      else:fail_open args:[resp]
  end

  block watch(h:i32, resp:ptr)
    let watch_id: i64 = 1:i64
    let n1: i32 = loop_watch(h, 1:i32, handle, events, watch_id, 0:i32, resp, 1024:i32)
    let ok1: bool = loop_resp_ok(resp, n1, loop_op_watch(), 1:i32)
    term.cbr cond:ok1,
      then:loop_init args:[h, resp, watch_id],
      else:watch_err args:[h, resp, n1]
  end

  block watch_err(h:i32, resp:ptr, n1:i32)
    let nosys_trace: ptr = "sem.sys_loop.nosys"
    let is_nosys: bool = loop_resp_err_trace_is(resp, n1, loop_op_watch(), 1:i32, nosys_trace, 18:i32)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:select(i32, is_nosys, loop_wait_rc_nosys(), loop_wait_rc_watch_failed())
  end

  block loop_init(h:i32, resp:ptr, watch_id:i64)
    term.br to loop args:[h, resp, watch_id, timeout_ms]
  end

  block loop(h:i32, resp:ptr, watch_id:i64, remaining:i32)
    let inf: bool = i32.cmp.eq(remaining, -1:i32)
    term.cbr cond:inf,
      then:poll_inf args:[h, resp, watch_id],
      else:poll_fin args:[h, resp, watch_id, remaining]
  end

  block poll_inf(h:i32, resp:ptr, watch_id:i64)
    let n2: i32 = loop_poll(h, 2:i32, 16:i32, -1:i32, resp, 1024:i32)
    let ok2: bool = loop_resp_ok(resp, n2, loop_op_poll(), 2:i32)
    term.cbr cond:ok2,
      then:check_ready_inf args:[h, resp, watch_id, n2],
      else:poll_err args:[h, resp, watch_id]
  end

  block check_ready_inf(h:i32, resp:ptr, watch_id:i64, n2:i32)
    let ok_ready: bool = loop_poll_has_ready(resp, n2, 2:i32, handle, watch_id, events)
    term.cbr cond:ok_ready,
      then:exit_ready args:[h, resp, watch_id],
      else:loop args:[h, resp, watch_id, -1:i32]
  end

  block poll_fin(h:i32, resp:ptr, watch_id:i64, remaining:i32)
    let done: bool = i32.cmp.sle(remaining, 0:i32)
    term.cbr cond:done,
      then:exit_timeout args:[h, resp, watch_id],
      else:poll_step args:[h, resp, watch_id, remaining]
  end

  block poll_step(h:i32, resp:ptr, watch_id:i64, remaining:i32)
    let step0: bool = i32.cmp.sle(poll_step_ms, 0:i32)
    let slice: i32 = select(i32, step0, remaining, loop_i32_min(remaining, poll_step_ms))
    let n2: i32 = loop_poll(h, 2:i32, 16:i32, slice, resp, 1024:i32)
    let ok2: bool = loop_resp_ok(resp, n2, loop_op_poll(), 2:i32)
    term.cbr cond:ok2,
      then:check_ready_fin args:[h, resp, watch_id, remaining, slice, n2],
      else:poll_err args:[h, resp, watch_id]
  end

  block check_ready_fin(h:i32, resp:ptr, watch_id:i64, remaining:i32, slice:i32, n2:i32)
    let ok_ready: bool = loop_poll_has_ready(resp, n2, 2:i32, handle, watch_id, events)
    term.cbr cond:ok_ready,
      then:exit_ready args:[h, resp, watch_id],
      else:cont args:[h, resp, watch_id, remaining, slice]
  end

  block cont(h:i32, resp:ptr, watch_id:i64, remaining:i32, slice:i32)
    let remaining2: i32 = i32.sub(remaining, slice)
    term.br to loop args:[h, resp, watch_id, remaining2]
  end

  block poll_err(h:i32, resp:ptr, watch_id:i64)
    let ignored_unwatch: i32 = loop_unwatch(h, 3:i32, watch_id, resp, 1024:i32)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:loop_wait_rc_poll_failed()
  end

  block exit_ready(h:i32, resp:ptr, watch_id:i64)
    let ignored_unwatch: i32 = loop_unwatch(h, 3:i32, watch_id, resp, 1024:i32)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:loop_wait_rc_ready()
  end

  block exit_timeout(h:i32, resp:ptr, watch_id:i64)
    let ignored_unwatch: i32 = loop_unwatch(h, 3:i32, watch_id, resp, 1024:i32)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:loop_wait_rc_timeout()
  end

  block fail_open(resp:ptr)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:loop_wait_rc_open_failed()
  end
end

fn loop_wait_readable_until(handle:i32, timeout_ms:i32) -> i32
  return loop_wait_events_until(handle, loop_watch_ev_readable(), timeout_ms, 50:i32)
end

fn loop_wait_writable_until(handle:i32, timeout_ms:i32) -> i32
  return loop_wait_events_until(handle, loop_watch_ev_writable(), timeout_ms, 50:i32)
end

fn loop_sleep_ms(ms:i32) -> i32
  ;; MVP "sleep" implemented via sys/loop timers.
  block entry
    let h: i32 = loop_open()
    let resp: ptr = zi_alloc(512:i32)
    let ok_open: bool = i32.cmp.sge(h, 3:i32)
    term.cbr cond:ok_open,
      then:arm args:[h, resp],
      else:fail_open args:[resp]
  end

  block arm(h:i32, resp:ptr)
    let due_ns: i32 = i32.mul(ms, 1000000:i32)
    let timer_id: i32 = 1:i32
    let n1: i32 = loop_timer_arm(h, 1:i32, timer_id, due_ns, 0:i32, 1:i32, resp, 512:i32)
    let ok1: bool = loop_resp_ok(resp, n1, loop_op_timer_arm(), 1:i32)
    term.cbr cond:ok1,
      then:poll args:[h, resp, timer_id],
      else:fail_arm args:[h, resp]
  end

  block poll(h:i32, resp:ptr, timer_id:i32)
    let timeout: i32 = i32.add(ms, 100:i32)
    let n2: i32 = loop_poll(h, 2:i32, 4:i32, timeout, resp, 512:i32)
    let ok2: bool = loop_poll_has_timer(resp, n2, 2:i32, timer_id)
    term.cbr cond:ok2,
      then:ok args:[h, resp],
      else:fail_poll args:[h, resp]
  end

  block ok(h:i32, resp:ptr)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:0:i32
  end

  block fail_open(resp:ptr)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:1:i32
  end

  block fail_arm(h:i32, resp:ptr)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:2:i32
  end

  block fail_poll(h:i32, resp:ptr)
    let ignored_end: i32 = zi_end(h)
    let ignored_free: i32 = zi_free(resp)
    term.ret value:3:i32
  end
end
